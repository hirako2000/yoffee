{"version":3,"file":"yoffee.min.js","sources":["../src/YoffeeElement.js","../src/objectWatcher.js","../src/domNodeFinder.js","../src/utils.js","../src/boundNode.js","../src/expression.js","../src/yoffee.js"],"sourcesContent":["// Simple class to achieve React-like behaviour, while using web standards and Yoffee.js.\n// Technologies: CustomElements, ShadowRoot, MutationObserver, Attributes.\nclass YoffeeElement extends HTMLElement {\n    updateProp (attr) {\n        // There are two cases:\n        // 1. We are updating a regular attribute (a=3)\n        // 2. We are updating an object prop/attribute (a={something: 3}) that yoffee created. Attributes can't be\n        //    objects, so when an attribute is set with an object, yoffee sets the attribute to \"__obj_placeholder__\"\n        //    and sets a property on the element with the actual value.\n        let attrValue = (this[attr] === undefined ? this.getAttribute(attr) : this[attr]);\n        if (attrValue === \"\") {\n            this.props[attr] = true // When attribute values are not specified, they're true. Example: <div hidden></div>\n        } else {\n            this.props[attr] = attrValue\n        }\n    };\n\n    constructor(state) {\n        super();\n        // Yoffee can add 'props' property when element is not yet initialized, and we need to remember them.\n        this.props = this.props || {};\n        this.state = state || {};\n\n        // Put current attributes into props\n        [...this.attributes].forEach(attr => this.updateProp(attr.name));\n\n        // Observe the custom element for attribute changes using MutationObserver, and update the props\n        // Note: \"attributeChangedCallback\" is not good enough because it requires a static \"observedAttributes\", and\n        // we don't ask the user to declare his props beforehand\n        const addProp = mutationsList => mutationsList.forEach(mutation => {\n            this.updateProp(mutation.attributeName);\n            this.propUpdatedCallback && this.propUpdatedCallback(mutation.attributeName)\n        });\n        new MutationObserver(addProp).observe(this, {attributes: true});\n\n        // Add shadow DOM\n        this.attachShadow({mode: 'open'});\n\n        // Create yoffee template and append to custom element\n        this._yoffeeFragment = this.render();\n        this.shadowRoot.appendChild(this._yoffeeFragment)\n    }\n\n    disconnectedCallback() {\n        this._yoffeeFragment.__removeWatchers()\n    }\n\n    connectedCallback() {\n        // This is here for when users call `super.connectedCallback()`. Prevent the crash :)\n    }\n\n    propUpdatedCallback() {\n        // This is here for when users call `super.propUpdatedCallback()`. Prevent the crash. :(\n    }\n}\n\nfunction createYoffeeElement(elementName, element) {\n    if (element.prototype instanceof YoffeeElement) {\n        // If we get a YoffeeElement, we just define it\n        customElements.define(elementName, element);\n    } else if (element instanceof Function) {\n        // If we get a cb, we wrap it with YoffeeElement\n        customElements.define(elementName, class extends YoffeeElement {\n            render() {\n                return element(\n                    this.props,\n                    this\n                )\n            }\n\n            propUpdatedCallback(prop) {\n                super.propUpdatedCallback()\n                this.onPropUpdate && this.onPropUpdate(prop)\n            }\n\n            connectedCallback() {\n                super.connectedCallback()\n                this.onConnect && this.onConnect()\n            }\n\n            disconnectedCallback() {\n                super.disconnectedCallback();\n                this.onDisconnect && this.onDisconnect()\n            }\n        })\n    } else {\n        throw `YOFFEE: \\`createYoffeeElement\\` second parameter must be either a YoffeeElement subclass or a function, Got ${typeof renderCb}`\n    }\n}\n\nexport {YoffeeElement, createYoffeeElement};\n","// TODO: Make library.\n\nconst NoWatchProperty = \"__notWatchedProp\"\n\n/** @type {Map<Object, [{onGet: Function, onSet: Function}]>} */\nconst objToListeners = new Map();\n\n/**\n * Calls `onGet` and `onSet` each time a property is accessed / set.\n * It does so by wrapping the object with property accessors and proxying.\n * @param {Object} object\n * @param {Function} onGet\n * @param {Function} onSet\n */\nfunction watch(object, onGet, onSet) {\n    let listeners = objToListeners.get(object);\n    if (listeners == null) {\n        listeners = [{onGet, onSet}];\n        objToListeners.set(object, listeners);\n        watchObject(\n            object,\n            prop => listeners.forEach(getset => getset.onGet(prop, object)),\n            (prop, value) => listeners.forEach(getset => getset.onSet(prop, value, object))\n        )\n    } else {\n        listeners.push({onGet, onSet})\n    }\n}\n\nfunction removeWatcher(object, onGet, onSet) {\n    let listeners = objToListeners.get(object);\n    if (listeners != null) {\n        let index = listeners.findIndex(listener => listener.onGet === onGet && listener.onSet === onSet);\n        if (index !== -1) {\n            listeners.splice(index, 1)\n        }\n    }\n}\n\nfunction watchObject(object, onGet, onSet) {\n    const propsHolder = {};\n\n    const wrapWithGetSet = propertyName => {\n        Object.defineProperty(object, propertyName, {\n            get() {\n                onGet && onGet(propertyName);\n                return propsHolder[propertyName]\n            },\n            set(value) {\n                propsHolder[propertyName] = value;\n                onSet && onSet(propertyName, value);\n            }\n        });\n    };\n\n    // Wrap existing properties with getters & setters\n    const properties = Object.getOwnPropertyDescriptors(object);\n    for (let propertyName of Object.keys(properties)) {\n        if (propertyName === NoWatchProperty) {\n            continue\n        }\n        propsHolder[propertyName] = object[propertyName];\n        wrapWithGetSet(propertyName)\n    }\n\n    // Use proxy to intercept new properties\n    Object.setPrototypeOf(object, new Proxy(propsHolder, {\n        get(target, propertyName) {\n            // This is only called when trying to get non existing props.\n            wrapWithGetSet(propertyName);\n            Reflect.get(object, propertyName)\n        },\n        set(target, propertyName, value) {\n            wrapWithGetSet(propertyName);\n            object[propertyName] = value;\n            return true;\n        }\n    }));\n}\n\nexport {watch, removeWatcher, NoWatchProperty}\n","// TODO: make library\n\nconst SearchLocations = {\n    TEXT_NODE: \"Text/CSS node\",\n    ATTR_VALUE: \"Attribute value\",\n    ATTR_NAME: \"Attribute name\",\n    HTML_TAG: \"HTML tag\"\n};\n\n/**\n *\n * @param rootElement\n * @param searchValue\n * @returns {{domNode: Node, searchLocation: String} | null}\n */\nfunction find(rootElement, searchValue) {\n    const xpathSearchers = [\n        {\n            // Finds TextNode by text\n            type: SearchLocations.TEXT_NODE,\n            xpath: `.//text()[contains(., '${searchValue}')]`\n        }, {\n            // Finds Attribute by value\n            type: SearchLocations.ATTR_VALUE,\n            xpath: `.//@*[contains(., '${searchValue}')]`\n        }, {\n            // Finds Attribute by attribute's name\n            type: SearchLocations.ATTR_NAME,\n            xpath: `.//@*[contains(name(), '${searchValue}')]`\n        }, {\n            // Finds HTML elements by tag names\n            type: SearchLocations.HTML_TAG,\n            xpath: `.//*[contains(name(), '${searchValue}')]`\n        }\n    ];\n\n    for (let searcher of xpathSearchers) {\n        let result = document.evaluate(\n            searcher.xpath,\n            rootElement,\n            null, XPathResult.FIRST_ORDERED_NODE_TYPE, null\n        ).singleNodeValue;\n\n        if (result != null) {\n            return {\n                domNode: result,\n                searchLocation: searcher.type\n            }\n        }\n    }\n}\n\nexport {find, SearchLocations}\n","function fillStrWithExpressions(str, expressions) {\n    for (let exp of expressions) {\n        str = str.replace(exp.id, \"${\" + exp._cb.toString() + \"}\")\n    }\n    return str\n}\n\nfunction randomId() {\n    return new Array(4).fill(0).map(\n        () => Math.random().toString(36).substr(2, 9)).join(\"-\");\n}\n\nfunction addToListInMap(map, key, item) {\n    let list = map.get(key)\n    if (list != null) {\n        list.push(item)\n    } else {\n        map.set(key, [item])\n    }\n}\n\nfunction addToSetInMap(map, key, item) {\n    let list = map.get(key)\n    if (list != null) {\n        list.add(item)\n    } else {\n        map.set(key, new Set([item]))\n    }\n}\n\nfunction getLongestSubsequence(unordered) {\n    let rootNode = {\n        value: -999999999,\n        layer: 0,\n        parent: null,\n        index: null\n    };\n    let nodes = [rootNode];\n    for (let i = 0; i < unordered.length; i++) {\n        let orphan = unordered[i];\n        let adoptingFather = nodes[0];\n        for (let node of nodes) {\n            if (orphan > node.value && node.layer > adoptingFather.layer) {\n                adoptingFather = node;\n            }\n        }\n        nodes.push({\n            value: orphan,\n            layer: adoptingFather.layer + 1,\n            parent: adoptingFather,\n            index: i\n        });\n    }\n\n    let maxLayer = -1;\n    let bestNode = null;\n    for (let node of nodes) {\n        if (node.layer > maxLayer) {\n            bestNode = node;\n            maxLayer = node.layer;\n        }\n    }\n\n    let indices = [];\n    while(bestNode.parent !== null) {\n        indices.unshift(bestNode.index);\n        bestNode = bestNode.parent\n    }\n    return indices\n}\n\nexport {fillStrWithExpressions, randomId, addToListInMap, addToSetInMap, getLongestSubsequence}","import {SearchLocations} from \"./domNodeFinder.js\";\nimport {fillStrWithExpressions, getLongestSubsequence} from \"./utils.js\";\n\nclass BoundNode {\n    /**\n     * A single HTML node, containing all that's needed\n     * @param {[Expression]} expressions\n     * @param {HTMLElement} domNode\n     * @param {String} expressionsLocation\n     */\n    constructor(expressions, domNode, expressionsLocation) {\n        this.expressions = expressions;\n        this.domNode = domNode;\n        this.expressionsLocation = expressionsLocation;\n        this._arrayDomNodes = [];\n\n        /**\n         * @type String\n         * The value of the node before IDs were replaced with their values\n         */\n        this.initialValue = {\n            // TextNode content\n            [SearchLocations.TEXT_NODE]: () => domNode.data,\n            // Attribute value\n            [SearchLocations.ATTR_VALUE]: () => domNode.value,\n            // Attribute name\n            [SearchLocations.ATTR_NAME]: () => domNode.name,\n        }[expressionsLocation]();\n        this.ownerElement = this.domNode.ownerElement // The element that owns an AttributeNode\n    }\n\n    update() {\n        if (this.expressionsLocation === SearchLocations.TEXT_NODE) {\n            this._updateTextNodeValue()\n        } else if (this.expressionsLocation === SearchLocations.ATTR_VALUE) {\n            this._updateAttributeNodeValue()\n        } else if (this.expressionsLocation === SearchLocations.ATTR_NAME) {\n            this._updateAttributeNodeName()\n        }\n    }\n\n    _updateTextNodeValue() {\n        // Text nodes will always have one expression only, because we break up text node into smaller ones\n        let expression = this.expressions[0];\n\n        // Do not modify node with cached expression\n        if (expression.cached) {\n            return;\n        }\n\n        let newValue = expression.lastResult;\n\n        if (newValue == null || newValue === false) {\n            newValue = \"\"\n        }\n\n        // Remove old array\n        if (this._lastTextNodeValue instanceof Array && !(newValue instanceof Array)) {\n            // TODO: Keyed logic for performance: dont delete all, only changed keys\n            // Delete old array, make domNode the last remaining value\n            for (let domNodeToRemove of this._arrayDomNodes) {\n                this._removeDomNode(domNodeToRemove);\n            }\n            this._arrayDomNodes = [];\n        }\n\n        // Unpack documentFragment\n        if (newValue instanceof DocumentFragment) {\n            if (newValue.childNodes.length === 0) {\n                newValue = \"\";\n            } else if (newValue.childNodes.length === 1) {\n                newValue = newValue.firstChild;\n            } else {\n                newValue = [...newValue.childNodes];\n            }\n        }\n\n        // Insert new array\n        if (newValue instanceof Array) {\n            // Create location marker if there isn't\n            if (!(this._lastTextNodeValue instanceof Array)) {\n                let listLocationMarker = document.createElement(\"yoffee-list-location-marker\");\n                this.domNode.replaceWith(listLocationMarker);\n                this.domNode = listLocationMarker;\n            }\n\n            // We need to apply DOM diffing algorithm.\n\n            // TODO: REVIVE SMART ALGORITHM...!\n            // // Remember order of new elements\n            // let elementToIndex = new Map();\n            // for (let i = 0; i < newValue.length; i++) {\n            //     let newArrayElement = typeof newValue[i] === \"number\" ? newValue[i].toString() : newValue[i];\n            //     elementToIndex.set(newArrayElement, i)\n            // }\n            //\n            // // Delete old elements which are not in new element list\n            // let elementsOrder = [];\n            // this._arrayDomNodes = this._arrayDomNodes.filter(existingDomNode => {\n            //     // Text nodes should be checked by their content equality and not reference equality\n            //     let elementToCheck = existingDomNode instanceof Text ? existingDomNode.data : existingDomNode;\n            //\n            //     // Checking if existingDomNode is also in the new list\n            //     if (elementToIndex.has(elementToCheck)) {\n            //         elementsOrder.push(elementToIndex.get(elementToCheck));\n            //         return true;\n            //     }\n            //\n            //     // If not, we destroy it.\n            //     this._removeDomNode(existingDomNode);\n            // });\n            //\n            // // Find longest subsequence of elements which we will keep in DOM for performance\n            // let cachedIndicesInNewList = getLongestSubsequence(elementsOrder).map(index => elementsOrder[index]);\n            // let cachedElementsInNewList = cachedIndicesInNewList.map(i => typeof newValue[i] === \"number\" ? newValue[i].toString() : newValue[i])\n            //\n            // // Remove old elements from dom which aren't ordered (later we insert them at the right index)\n            // this._arrayDomNodes = this._arrayDomNodes.filter((existingDomNode, index) => {\n            //     let elementToCheck = existingDomNode instanceof Text ? existingDomNode.data : existingDomNode;\n            //     if (!cachedElementsInNewList.includes(elementToCheck)) {\n            //         this._removeDomNode(existingDomNode);\n            //         return false\n            //     }\n            //     return true\n            // });\n            //\n            // // Now we insert all new elements except those that already exist in remainingOldIndices\n            // let indexOfNextRemaining = 0;\n            // let nextRemainingElement = this._arrayDomNodes[0];\n            // let nextArrayDomNodes = [];\n            // let insert = element => {\n            //     if (nextRemainingElement == null) {\n            //         this.domNode.parentNode.insertBefore(element, this.domNode)\n            //     } else {\n            //         this.domNode.parentNode.insertBefore(element, nextRemainingElement)\n            //     }\n            // }\n            //\n            // for (let i = 0; i < newValue.length; i++) {\n            //     if (i === cachedIndicesInNewList[indexOfNextRemaining]) {\n            //         nextArrayDomNodes.push(this._arrayDomNodes[indexOfNextRemaining]);\n            //         if (indexOfNextRemaining < cachedIndicesInNewList.length) {\n            //             indexOfNextRemaining += 1;\n            //             nextRemainingElement = this._arrayDomNodes[indexOfNextRemaining];\n            //         }\n            //     } else {\n            //         let arrayValue = newValue[i];\n            //         arrayValue = typeof arrayValue === \"object\" ? arrayValue : document.createTextNode(arrayValue)\n            //         nextArrayDomNodes.push(arrayValue);\n            //\n            //         if (arrayValue.__isYoffee) {\n            //             for (let childNode of arrayValue.__childNodes) {\n            //                 insert(childNode);\n            //             }\n            //         } else {\n            //             insert(arrayValue);\n            //         }\n            //     }\n            // }\n            // this._arrayDomNodes = nextArrayDomNodes;\n\n            let newArrayDomNodes = [];\n            let currentElement = null;\n            let insert = element => {\n                // If the first element is inserted before cached elements, it should be inserted before the first old\n                // element in the list. If there are none, it would be just inserted before the list marker\n                if (currentElement == null) {\n                    if (this._arrayDomNodes[0] == null) {\n                        this.domNode.parentNode.insertBefore(element, this.domNode)\n                    } else {\n                        this.domNode.parentNode.insertBefore(\n                            element,\n                            (this._arrayDomNodes[0].__isYoffee ? this._arrayDomNodes[0].__childNodes[0] : this._arrayDomNodes[0])\n                        )\n                    }\n                } else {\n                    // Here we insert element in the middle of the list, after currentElement\n                    this.domNode.parentNode.insertBefore(\n                        element,\n                        currentElement.nextSibling\n                    )\n                }\n                currentElement = element.__isYoffee ? element.__childNodes[element.__childNodes.length - 1] : element;\n            }\n\n            for (let newElement of newValue) {\n                if (newElement == null) {\n                    continue\n                }\n\n                let oldElement = this._arrayDomNodes[0];\n                if (oldElement != null &&\n                    (oldElement instanceof Text ? oldElement.data : oldElement) ===\n                    (typeof newElement === \"number\" ? newElement.toString() : newElement)\n                ) {\n                    newArrayDomNodes.push(oldElement);\n                    currentElement = oldElement.__isYoffee ?\n                        oldElement.__childNodes[oldElement.__childNodes.length - 1] : oldElement;\n                    this._arrayDomNodes.shift();\n                } else {\n                    newElement = typeof newElement === \"object\" ? newElement : document.createTextNode(newElement)\n                    newArrayDomNodes.push(newElement);\n\n                    if (newElement.__isYoffee) {\n                        // The reason we keep yoffee documentFragments in _arrayDomNodes is because of caching\n                        for (let childNode of newElement.__childNodes) {\n                            insert(childNode);\n                        }\n                    } else if (newElement instanceof Array) {\n                        // TODO: Why not, actually???????????????????????????????????\n                        throw \"YOFFEE: List item cannot be another list\"\n                    } else {\n                        insert(newElement);\n                    }\n                }\n            }\n\n            for (let oldDomNode of this._arrayDomNodes) {\n                if (newArrayDomNodes.indexOf(oldDomNode) === -1) {\n                    this._removeDomNode(oldDomNode);\n                }\n            }\n\n            this._arrayDomNodes = newArrayDomNodes;\n        } else if (typeof newValue === \"object\") {\n            // Either element or object. If object, wat do we do??\n            // TODO: WAT DO WE DO?\n            if (!(newValue instanceof Node)) {\n                throw \"YOFFEE: Text value can't be a regular JS object!\"\n            }\n            this.domNode.replaceWith(newValue);\n            this.domNode = newValue;\n        } else {\n            // TODO: If value is same as last, don't replace. just let it beef\n            if (typeof this._lastTextNodeValue === \"object\") {\n                // Replace old object/list with string\n                let newTextNode = document.createTextNode(newValue);\n                this.domNode.replaceWith(newTextNode);\n                this.domNode = newTextNode;\n            } else {\n                // If just string\n                if (this.domNode.data !== newValue.toString()) {\n                    this.domNode.data = newValue;\n                }\n            }\n        }\n\n        this._lastTextNodeValue = newValue;\n    }\n\n    _removeDomNode(domNode) {\n        // If domNode is __isYoffee, kill all children because it's a DocumentFragment. Note: checking for\n        // DocumentFragments would be wrong, because we never store DocumentFragments which aren't yoffee\n        // template in `this._arrayDomNodes`.\n        if (domNode.__isYoffee) {\n            for (let childNode of domNode.__childNodes) {\n                childNode.remove();\n            }\n        } else {\n            domNode.remove()\n        }\n    }\n\n    _updateAttributeNodeValue() {\n        // Checks if expression is an event handler, and adds an event listener if true.\n        if (this.expressions[0].isEventHandler) {\n            if (this.expressions.length > 1) {\n                let forbiddenEventHandlerText = fillStrWithExpressions(this.initialValue, this.expressions);\n                throw `YOFFEE: Cant have more than one expression as event handler: ${forbiddenEventHandlerText}`\n            }\n            this._setEventListener();\n        } else {\n            let lastResult = this.expressions[0].lastResult;\n\n            // Check if there is only one expression, and no fixed text as well (by comparing the expression length)\n            let isJustExpression = this.expressions.length === 1 && this.initialValue.length === this.expressions[0].id.length;\n\n            if (isJustExpression && (lastResult === false || lastResult == null)) {\n                // If value is falsy, remove the attribute\n                this.ownerElement[this.domNode.name] = undefined;\n                this.ownerElement.removeAttribute(this.domNode.name);\n            } else if (isJustExpression && [\"function\", \"object\"].includes(typeof lastResult)) {\n                // If attr value is function or object, set it directly as a property of the element instead of\n                // attribute, because attributes can only hold strings\n                setPropOnPotentialYoffeeElement(this.ownerElement, this.domNode.name, lastResult)\n\n                // Remove the attribute (First check if we already removed it before)\n                if (this.domNode.ownerElement != null) {\n                    this.domNode.ownerElement.removeAttributeNode(this.domNode);\n                }\n            } else if (isJustExpression && lastResult === true) {\n                // If we get true, just set the attribute with no value (<div a></div>)\n                this.ownerElement[this.domNode.name] = undefined;\n                this._setDomNode(\"\");\n            } else {\n                // Has to be done before setDomNode\n                this.ownerElement[this.domNode.name] = undefined;\n\n                // If string, replaces original value ids with expression values\n                let newValue = this.initialValue;\n                for (let expression of this.expressions) {\n                    newValue = newValue.replace(expression.id, expression.lastResult)\n                }\n                this._setDomNode(newValue);\n            }\n        }\n    }\n\n    _setDomNode(value) {\n        this.domNode.value = value;\n        if (this.domNode.ownerElement == null) {\n            this.ownerElement.setAttributeNode(this.domNode)\n        }\n    }\n\n    _updateAttributeNodeName() {\n        let lastResult = this.expressions[0].lastResult;\n        let isJustExpression = this.expressions.length === 1 && this.initialValue.length === this.expressions[0].id.length;\n\n        // Because changing an attribute name is impossible, we must remove the attributes and creates new ones with updated names\n        if (this._lastAttributeMap) {\n            // Removes last attribute mapping if there was\n            // TODO: Dont remove all, replace only different ones...\n            for (let [attrName, _] of this._lastAttributeMap) {\n                this.ownerElement.removeAttribute(attrName);\n                removePropFromPotentialYoffeeElement(this.ownerElement, attrName)\n            }\n            this._lastAttributeMap = null\n        } else {\n            // Removes last attribute\n            // TODO: Dont remove if they're same\n            this.ownerElement.removeAttribute(this.domNode.name)\n        }\n\n        if (isJustExpression && (lastResult === false || lastResult == null || lastResult === \"\")) {\n            // Don't add any attribute if value is falsy\n            return\n        }\n\n        if (isJustExpression && typeof lastResult === \"object\") {\n            // If we get an object, insert it as key-value mapping of attributes\n            this._lastAttributeMap = Object.entries(lastResult)\n            for (let [attrName, value] of this._lastAttributeMap) {\n                if (value !== false && value !== null) {\n                    if ([\"function\", \"object\"].includes(typeof value)) {\n                        // this.ownerElement.setAttribute(attrName, \"__obj_placeholder__\");\n                        // this.ownerElement[attrName] = value\n\n                        setPropOnPotentialYoffeeElement(this.ownerElement, attrName, value)\n\n                        // Remove the attribute (First check if we already removed it before)\n                        if (this.domNode.ownerElement != null) {\n                            this.domNode.ownerElement.removeAttributeNode(this.domNode);\n                        }\n\n                    } else {\n                        if (value === true) {\n                            value = \"\"\n                        }\n                        this.ownerElement.setAttribute(attrName, value);\n                    }\n                }\n            }\n        } else {\n            // If string, replaces ids with expression values\n            let newName = this.initialValue;\n            for (let expression of this.expressions) {\n                newName = newName.replace(expression.id, expression.lastResult)\n            }\n\n            this.ownerElement.setAttribute(newName, this.domNode.value);\n            this.domNode = this.ownerElement.getAttributeNode(newName);\n        }\n    }\n\n    /**\n     * Replaces attribute node that starts with \"on\" with event listener.\n     * This will never run twice on the same expression, because no props are linked, because event handler expressions\n     * don't evaluate until the event is caught.\n     * @private\n     */\n    _setEventListener() {\n        let listenerName = this.domNode.name; // For example, 'onclick'\n        let eventName = listenerName.substring(2); // Remove the `on` from `onclick`\n\n        // The function that will handle both the event and the callback function property\n        let handleEvent = (...args) => {\n            const result = this.expressions[0].lastResult(...args);\n\n            // In case expression returns another function (user wrote ${() => () => print(\"stuff)} for example)\n            if (typeof result === \"function\") {\n                return result(...args)\n            }\n\n            // TODO: If user returned a string (onclick=\"${() => state.wat ? \"alert(1)\" : \"alert(2)}\") we should eval that\n            return result\n        }\n\n        // TODO: Remove event listener when the value changes!!! (like the attribute being deleted, then added again?)\n        // Setting event listener\n        this.domNode.ownerElement.addEventListener(eventName, handleEvent);\n\n        // Adding callback function property as well\n        setPropOnPotentialYoffeeElement(this.domNode.ownerElement, listenerName, handleEvent)\n\n        // Remove the attribute\n        this.domNode.ownerElement.removeAttributeNode(this.domNode);\n    }\n}\n\nfunction setPropOnPotentialYoffeeElement(element, propName, propValue) {\n    // First, setting property on element\n    element[propName] = propValue\n\n    // Checking if element is initialized or still an UnknownHTMLElement. If initilized, call `updateProp`\n    if (element.updateProp) {\n        element.updateProp(propName)\n    } else {\n        // If not initialized, keep everything in props until it is initialized\n        if (element.props == null) {\n            element.props = {}\n        }\n        element.props[propName] = propValue\n    }\n}\n\nfunction removePropFromPotentialYoffeeElement(element, propName) {\n    // First, setting property on element\n    element[propName] = undefined\n\n    // Checking if element is initialized or still an UnknownHTMLElement. If initilized, call `updateProp`\n    if (element.updateProp) {\n        element.updateProp(propName)\n    } else {\n        // If not initialized, keep everything in props until it is initialized\n        if (element.props == null) {\n            element.props = {}\n        }\n        element.props[propName] = undefined\n    }\n}\n\nexport {BoundNode}","import {randomId, addToListInMap} from \"./utils.js\";\n\nfunction arraysEqual(a, b) {\n    if (a.length !== b.length) return false;\n\n    for (let i = 0; i < a.length; ++i) {\n        if (a[i] !== b[i]) return false;\n    }\n    return true;\n}\n\nfunction isHashSame(hash, propsObjs, hash2, propsObjs2) {\n    return hash === hash2 && arraysEqual(propsObjs, propsObjs2)\n}\n\nfunction mutationFilter(arr, cb) {\n    for (let i = arr.length - 1; i >= 0; i -= 1) {\n        if (!cb(arr[i])) {\n            arr.splice(i, 1)\n        }\n    }\n}\n\nconst ExpResultTypes = {\n    PRIMITIVE: \"primitive\",\n    ARRAY: \"array\",\n    YOFFEE_TEMPLATE: \"yoffee_template\"\n}\n\nclass Expression {\n    constructor(expressionCb) {\n        this._cb = expressionCb;\n        this.id = randomId();\n        this.lastResult = null;\n        this.boundNode = null;\n        this.boundProps = new Set()\n        this.isEventHandler = false;\n        this.isStatic = (typeof this._cb) !== \"function\";\n\n        this.resultType = null;\n        this.resultMetadata = null;\n    }\n\n    execute() {\n        // Resetting cached state\n        this.cached = false;\n\n        if (this.isEventHandler || this.isStatic) {\n            this.lastResult = this._cb;\n        } else {\n            let newResult = this._cb();\n\n            // Checks if the output is a yoffee template\n            if (newResult != null && newResult.createYoffeeTemplate) {\n                this.handleYoffeeTemplate(newResult);\n            } else if (Array.isArray(newResult)) {\n                this.handleArray(newResult);\n            // } else if (typeof newResult === \"object\" && newResult != null) {\n            //     this.handleKeyedList(newResult)\n            } else {\n                // Primitive value - just setting it and destroying all children\n                this.removeChildTemplateListeners();\n                this.lastResult = newResult;\n                this.resultType = ExpResultTypes.PRIMITIVE;\n                this.resultMetadata = null;\n            }\n        }\n    }\n\n    handleYoffeeTemplate(deferredTemplate) {\n        // In case we are recursive\n        if (this.resultType === ExpResultTypes.YOFFEE_TEMPLATE &&\n            this.resultMetadata.yoffeeTemplate == null) {\n            return\n        }\n\n        // Check if new template is the same as the last\n        if (this.resultType === ExpResultTypes.YOFFEE_TEMPLATE &&\n            // !this.resultMetadata.yoffeeTemplate.__contentChanged &&\n            // !this.resultMetadata.yoffeeTemplate.__weaklyBoundProps.has(TemplateStack.getCurrentlySetProp()) &&\n            this.resultMetadata.cacheable &&\n            isHashSame(this.resultMetadata.hash, this.resultMetadata.propsObjs, deferredTemplate.hash, deferredTemplate.propsObjs)\n        ) {\n            // Caching template\n            console.log(\"Using cached template\")\n            this.cached = true;\n            this.lastResult.__expressions.forEach((exp, index) => {\n                exp._cb = deferredTemplate.expressionCbs[index];\n            })\n            this.lastResult.__updateExpressions();\n        } else {\n            // Destroy all past yoffee children\n            this.removeChildTemplateListeners()\n\n            this.resultType = ExpResultTypes.YOFFEE_TEMPLATE;\n            this.resultMetadata = deferredTemplate\n            this.lastResult = deferredTemplate.createYoffeeTemplate();\n        }\n    }\n\n    handleArray(newResult) {\n        // Check if last result was an array, and cache existing yoffees\n        if (this.resultType === ExpResultTypes.ARRAY) {\n            let oldHashToTemplates = this.resultMetadata;\n\n            // // Filter out and remove watchers for yoffees with a changed content\n            // for (let templateList of oldHashToTemplates.values()) {\n            //     mutationFilter(templateList, t => {\n            //         // if (t.yoffeeTemplate.__contentChanged) {\n            //         if (t.yoffeeTemplate != null\n            //             && t.yoffeeTemplate.__weaklyBoundProps.has(TemplateStack.getCurrentlySetProp())\n            //         ) {\n            //             t.yoffeeTemplate.__removeWatchers();\n            //             return false\n            //         }\n            //         return true\n            //     });\n            // }\n\n            // Populate array with new and old values\n            this.lastResult = [];\n            let newHashToTemplates = new Map();\n\n            // Important to override resultMetadata here, because next code can call createYoffeeTemplate recursively\n            this.resultMetadata = newHashToTemplates;\n\n            for (let listItem of newResult) {\n                if (listItem != null && listItem.createYoffeeTemplate) {\n                    let cached = false;\n\n                    // Find old template with same hash and props objects\n                    let cachedTemplatesList = oldHashToTemplates.get(listItem.hash);\n                    if (cachedTemplatesList != null && listItem.cacheable) {\n                        // Finds templates with the same prop objects as the new one\n                        let cachedTemplateIndex = cachedTemplatesList.findIndex(\n                            t => arraysEqual(t.propsObjs, listItem.propsObjs)\n                        );\n                        if (cachedTemplateIndex !== -1) {\n                            // We must splice because we can't reuse one old template for multiple new templates!\n                            let cachedTemplate = cachedTemplatesList.splice(cachedTemplateIndex, 1)[0];\n                            cached = true\n\n                            // TODO: Do we need the if???\n                            // if (cachedTemplate.yoffeeTemplate != null) {\n\n                            console.log(\"Using cached template in list\")\n                            this.lastResult.push(cachedTemplate.yoffeeTemplate);\n                            cachedTemplate.shouldntDelete = true\n\n                            cachedTemplate.yoffeeTemplate.__expressions.forEach((exp, index) => {\n                                exp._cb = listItem.expressionCbs[index];\n                            })\n                            cachedTemplate.yoffeeTemplate.__updateExpressions();\n                            // }\n\n                            addToListInMap(newHashToTemplates, cachedTemplate.hash, cachedTemplate);\n                        }\n                    }\n\n                    // Old wasn't found, creating new\n                    if (!cached) {\n                        addToListInMap(newHashToTemplates, listItem.hash, listItem);\n                        let yoffeeTemplate = listItem.createYoffeeTemplate()\n                        this.lastResult.push(yoffeeTemplate);\n                    }\n                } else {\n                    this.lastResult.push(listItem)\n                }\n            }\n\n            // Delete old uncached yoffees\n            for (let templateList of oldHashToTemplates.values()) {\n                templateList.forEach(t => {\n                    if (!t.shouldntDelete) {\n                        t.yoffeeTemplate.__removeWatchers();\n                    }\n                });\n            }\n            for (let templateList of newHashToTemplates.values()) {\n                templateList.forEach(t => {\n                    if (t.shouldntDelete) {\n                        t.shouldntDelete = undefined\n                    }\n                });\n            }\n        } else {\n            // First array render: if last result wasn't array\n            this.removeChildTemplateListeners();\n\n            this.lastResult = [];\n            let hashToTemplates = new Map();\n            for (let item of newResult) {\n                if (item != null && item.createYoffeeTemplate) {\n                    let yoffeeTemplate = item.createYoffeeTemplate()\n                    this.lastResult.push(yoffeeTemplate)\n                    addToListInMap(hashToTemplates, item.hash, item);\n                } else {\n                    this.lastResult.push(item)\n                }\n            }\n\n            this.resultMetadata = hashToTemplates;\n        }\n        this.resultType = ExpResultTypes.ARRAY;\n    }\n\n    removeChildTemplateListeners() {\n        if (this.resultType == null) {\n            return\n        }\n\n        if (this.resultType === ExpResultTypes.YOFFEE_TEMPLATE) {\n            this.resultMetadata.yoffeeTemplate.__removeWatchers();\n        } else if (this.resultType === ExpResultTypes.ARRAY) {\n            this.lastResult.filter(item => item.__isYoffee).forEach(yoffeeTemplate => yoffeeTemplate.__removeWatchers());\n        }\n    }\n}\n\nexport {Expression}","import {YoffeeElement, createYoffeeElement} from \"./YoffeeElement.js\"\nimport {watch, removeWatcher, NoWatchProperty} from \"./objectWatcher.js\"\nimport {find, SearchLocations} from \"./domNodeFinder.js\"\nimport {randomId, fillStrWithExpressions} from \"./utils.js\";\nimport {BoundNode} from \"./boundNode.js\";\nimport {Expression} from \"./expression.js\";\n\nfunction _joinTemplateStrings(arr1, arr2) {\n    return arr2.reduce((accu, current, i) => accu + current + arr1[i + 1], arr1[0])\n}\n\n/**\n * Creates an HTML element from html string.\n * We use template tag, because it doesn't render its content. The `content` property of the template element is a\n * DocumentFragment that contains all the elements under that template.\n * The reason we create an enclosing <yoffee-template-container> element and don't return the DocumentFragment directly,\n * is that document.evaluate can't run on a DocumentFragment, only on an element. So we enclose the template's content\n * with <yoffee-template-container>, and return that.\n * @param {String} html\n * @returns {Element}\n * @private\n */\nfunction _createContainerElement(html) {\n    let template = document.createElement(\"template\");\n\n    // yoffee-template-container doesn't exist, I made it up. It is an HTMLUnknownElement:\n    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLUnknownElement\n    html = html.trim();\n    let containerElement;\n\n    if ((html.startsWith(\"<tr\") || html.startsWith(\"<td\")) && (html[3] === \" \" || html[3] === \">\")) {\n        // // This works for creating the tr/td, but the real problem is that the expression itself is outside the table\n        // // because table can't contain stuff that's not legit content\n        // template.innerHTML = html;\n        //\n        // let template2 = document.createElement(\"template\");\n        // template2.innerHTML = \"<yoffee-template-container></yoffee-template-container>\"\n        // for (let child of template.content.children) {\n        //     template2.content.firstElementChild.appendChild(child)\n        // }\n        //\n        // containerElement = template2.content.firstElementChild;\n        throw `YOFFEE: Table tag is not supported`\n    } else {\n        template.innerHTML = `<yoffee-template-container>${html}</yoffee-template-container>`;\n        containerElement = template.content.firstElementChild;\n    }\n\n    // Firefox can't use document.evaluate on a node that's not under the document\n    if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {\n        // TODO: Check if you can use XMLDocument.evaluate to evaluate instead of adding to the DOM\n        return document.adoptNode(containerElement)\n    }\n    return containerElement\n}\n\n/**\n * Receives a textNode and divider (`textToMakeNode`), and breaks up the textNode into 3 textNodes: before, after and\n * middle, and returns the middle. The middle is the part that's equal to `textToMakeNode` and its value is changed to it.\n * the other parts are inserted into the DOM.\n * Example: node \"123\" with divider \"2\" will return insert \"1\" and \"3\" into the DOM, and return \"2\".\n * node \"23\" with divider \"2\" will insert \"3\" into DOM and return \"2\".\n * @param {Text} textNode\n * @param {String} textToMakeNode\n * @returns {Text}\n * @private\n */\nfunction _breakUpTextNodeToSmallerNodes(textNode, textToMakeNode) {\n    let wholeText = textNode.data.trim();\n    let textStartIndex = wholeText.indexOf(textToMakeNode);\n    let textEndIndex = textStartIndex + textToMakeNode.length;\n\n    // Insert node before\n    if (textStartIndex !== 0) {\n        textNode.parentNode.insertBefore(\n            document.createTextNode(wholeText.substring(0, textStartIndex)),\n            textNode\n        );\n    }\n\n    // Insert node after\n    if (textEndIndex < wholeText.length) {\n        textNode.parentNode.insertBefore(\n            document.createTextNode(wholeText.substring(textEndIndex)),\n            textNode.nextSibling\n        );\n    }\n\n    textNode.data = wholeText.substring(textStartIndex, textEndIndex);\n    return textNode;\n}\n\n/**\n * Creates BoundNodes from expressionIds inside `containerElement`.\n * Basically, we run over each expression and find it's ID inside the `containerElement`. It should be there somewhere.\n * For each ID we found we create a BoundNode, with the node that contains the ID and the expression.\n * Each BoundNode references a list of expressions, and each expression has a reference to its bound node.\n * @param {HTMLElement} containerElement\n * @param {[Expression]} expressions\n * @private\n */\nfunction bindNodesToExpressions(containerElement, expressions) {\n    /** @type {Map<Node, BoundNode>} */\n    const domNodeToBoundNode = new Map();\n\n    for (let expression of expressions) {\n        let searchResult = null;\n        searchResult = find(containerElement, expression.id);\n\n        if (searchResult == null) {\n            throw `YOFFEE: Expression location is not valid: ${\"${\" + expression._cb.toString() + \"}\"}`\n        }\n        let {domNode, searchLocation} = searchResult;\n\n        // Break up textNode\n        if (searchLocation === SearchLocations.TEXT_NODE) {\n            domNode = _breakUpTextNodeToSmallerNodes(domNode, expression.id)\n        }\n\n        // If template is inside html tag name, throw exception\n        if (searchLocation === SearchLocations.HTML_TAG) {\n            let forbiddenTagText = fillStrWithExpressions(`<${domNode.localName}>`, [expression]);\n            throw `YOFFEE: Calculating element name is not allowed: ${forbiddenTagText}`\n        }\n\n        // Expressions on attrs that start with \"on\" are event handlers\n        if (searchLocation === SearchLocations.ATTR_VALUE && domNode.name.startsWith(\"on\")) {\n            expression.isEventHandler = true;\n        }\n\n        // Create BoundNodes, deduping nodes that are found multiple times because of multiple expressions (attr node)\n        if (domNodeToBoundNode.has(domNode)) {\n            let boundNode = domNodeToBoundNode.get(domNode);\n            boundNode.expressions.push(expression);\n            expression.boundNode = boundNode;\n        } else {\n            let boundNode = new BoundNode([expression], domNode, searchLocation);\n            domNodeToBoundNode.set(domNode, boundNode);\n            expression.boundNode = boundNode;\n        }\n    }\n\n    // console.log(\"DomNodes + Expressions: \");\n    // console.log([...domNodeToBoundNode.values()]);\n}\n\nfunction hashTemplate(strings, expressionCbs) {\n    // Just zip two lists\n    // TODO: concatenating may cause a false equality. for example, \"<div>${()=>a}\" will be the same as \"<div>()=>${a}\"\n    let str = expressionCbs.reduce((accu, current, i) => accu + current + strings[i + 1], strings[0]);\n\n    // Hash result\n    return str.split(\"\").reduce(function (a, b) {\n        a = ((a << 5) - a) + b.charCodeAt(0);\n        return a & a\n    }, 0);\n}\n\n\n/** @type {Map<String, Set<Expression>>} */\nlet propsToExpressions = new Map();\n\n// TODO: Remove this.?\nlet currentlySetProp = null;\n\n/** @type {Boolean} */\nlet isInsideExpression = false;\n\n/**\n * Contains a set of props that were accessed so far when executing chain of expressions. This is important, because\n * if parent expressions accessed prop A and then his child expression also accessed it, child shouldn't rerender;\n * only parent should, and parent will execute his children himself.\n * @type {Set<String>}\n */\nlet propsAlreadyAccessed = new Set();\n\n/** @type {Expression} */\nlet currentlyExecutingExpression = null;\n\n\n/**\n * Called when any property was accessed on any prop object.\n * Responsible for:\n *  - Linking props to expressions in which they were accessed\n *  - Accumulating props that were accessed in expression chain\n *  - Updating list of `boundProps` on the current executing expression\n * @param {String} key\n * @param {Object} obj\n */\nlet onGetListener = (key, obj) => {\n    if (!isInsideExpression) {\n        return\n    }\n\n    // We use the props object's ID as prefix because the same prop in different props objects has to be different\n    let prop = `${obj[NoWatchProperty]}.${key}`;\n\n    // We accumulate props that were already accessed when executing chain of expressions.\n    // If prop wasn't accessed earlier, we count it in `propsAlreadyAccessed`, and add it to the list of boundProps\n    // on the current executing expression.\n    // If prop was accessed earlier in the expression chain, we don't attribute it to anything.\n    if (!propsAlreadyAccessed.has(prop)) {\n        propsAlreadyAccessed.add(prop);\n        currentlyExecutingExpression.boundProps.add(prop);\n        if (!propsToExpressions.has(prop)) {\n            propsToExpressions.set(prop, new Set());\n        }\n        propsToExpressions.get(prop).add(currentlyExecutingExpression);\n    }\n}\n\n/**\n * Called when any property is set on any props object.\n * Collects expressions which are linked to the updated property, and executes them. simple and stupid.\n * @param {String} key\n * @param value\n * @param {Object} obj\n */\nlet onSetListener = (key, value, obj) => {\n    if (isInsideExpression) {\n        throw `YOFFEE: Setting properties is not allowed inside an expression! (${key} = ${value})`\n    }\n\n    // TODO: Check if value is different than the current one, and spare expression evaluations\n    // We use the props object's ID as prefix because the same prop in different props objects has to be different\n    let prop = `${obj[NoWatchProperty]}.${key}`;\n\n    // The currently set prop is for when setting prop INSIDE an expression!\n    // TODO: Remove this. it doesnt do anything now\n    let oldPropPlaceholder = currentlySetProp;\n    currentlySetProp = prop;\n\n    // Collect expressions to execute (expressions that have props that were modified)\n    let expressionsToExecute = propsToExpressions.get(currentlySetProp);\n    if (expressionsToExecute == null) {\n        // TODO: Consider removing this warning. if one object has many yoffee elements it will happen annoyingly.\n        console.warn(`A prop changed but no expression is linked to it: ${\n            currentlySetProp.substr(currentlySetProp.indexOf(\".\") + 1)}`);\n        return;\n    }\n    updateExpressions([...expressionsToExecute], true)\n\n    currentlySetProp = oldPropPlaceholder;\n}\n\n/**\n * Receives a list of expressions, and executes them, updating the template afterwards.\n * This function is running in a recursive manner. It doesn't call itself, but expressions call it when they need to\n * execute child expressions. That's why we use 'old' parameters, like 'oldIsInsideExpression', to set back the global\n * value to what it was before function was called recursively.\n * @param {[Expression]} exs Expressions to execute\n * @param {Boolean?} startRenderMidTree If we're starting render mid-tree (when setting prop), we should remember\n * accessed props of ancestors\n */\nconst updateExpressions = (exs, startRenderMidTree) => {\n    let oldIsInsideExpression = isInsideExpression;\n    isInsideExpression = true;\n\n    try {\n        for (let expression of exs) {\n            // Remove all bound props, prepare to populate updated ones\n            expression.boundProps.forEach(boundProp => propsToExpressions.get(boundProp).delete(expression))\n\n            let oldAlreadyAccessedProps = new Set(propsAlreadyAccessed);\n            if (startRenderMidTree) {\n                // When we're starting a render chain (expression renders child expressions and so on...) in the middle\n                // of the tree of expressions, we need to remember which props were accessed by ancestors of the updated\n                // expression, and not attribute those properties to the children when they access them.\n                propsAlreadyAccessed = new Set(expression.__propsAccessedByFather || []);\n            } else {\n                expression.__propsAccessedByFather = new Set(propsAlreadyAccessed);\n            }\n            let oldCurrentlyExecutingExpression = currentlyExecutingExpression;\n            currentlyExecutingExpression = expression;\n            expression.execute();\n            currentlyExecutingExpression = oldCurrentlyExecutingExpression;\n            propsAlreadyAccessed = oldAlreadyAccessedProps;\n        }\n    } finally {\n        isInsideExpression = oldIsInsideExpression;\n    }\n\n    // Update nodes with updated expression results\n    for (let boundNode of new Set(exs.map(ex => ex.boundNode))) {\n        boundNode.update()\n    }\n};\n\n/**\n * Receives state objects, template strings and expression callbacks inside the template, and returns a template that's bound\n * to the props objects.\n *\n * Steps:\n * 1. Create a DocumentFragment that will represent the yoffee template (it will contain elements, reference listeners, etc.)\n * 2. Create HTML string from the template literal: generate an ID for each expression and replace the expressions in the template with those IDs.\n * 3. Create a HTMLUnknownElement element that contains the previously generated HTML string. It's not connected to the DOM.\n * 4. Bind nodes to expressions: find the DOM nodes that contain the expressions in the HTMLUnknownElement DOM using the previously generated IDs.\n *    We need the HTMLUnknownElement to search because xpath root has to be an Element (not DocumentFragment)\n * 5. Perform first render: execute each expression while collecting the state object's properties that were accesed inside, and insert the return value\n *    into the DOM Node where the expression ID was. When the state object's setter is invoked, we check whether the property is bound\n *    to any expression, and if so, the expression is executed and DOM Node is updated, and new properties are collected on the way again.\n * 6. Move all children of the container element into the DocumentFragment created earlier, and return the fragment.\n *\n *  When executing an expression, we know which props were used in the expression thanks to the watchers we set earlier.\n *\n * @param propsObjects\n * @param strings\n * @param expressionCbs\n * @returns {DocumentFragment}\n */\nfunction createBoundDocumentFragment(propsObjects, strings, expressionCbs) {\n    // Create the fragment that will be returned, which contains the template\n    let yoffeeFragment = document.createDocumentFragment();\n\n    yoffeeFragment.__isYoffee = true;\n\n    // Create expressions and yoffee element\n    const expressions = expressionCbs.map(cb => new Expression(cb));\n    let htmlText = _joinTemplateStrings(strings, expressions.map(e => e.id));\n    const containerElement = _createContainerElement(htmlText);\n\n    // After this, each expression will reference a single BoundNode, which references multiple expressions.\n    bindNodesToExpressions(containerElement, expressions);\n\n    // This is called when the template is replaced with something else\n    yoffeeFragment.__removeWatchers = () => {\n        console.log(\"Deleting template\");\n\n        for (let expression of expressions) {\n            expression.boundProps.forEach(boundProp => propsToExpressions.get(boundProp).delete(expression));\n            expression.removeChildTemplateListeners();\n        }\n    }\n\n    // Initial render\n    updateExpressions(expressions);\n\n    // Add nodes into yoffee fragment\n    yoffeeFragment.__childNodes = [...containerElement.childNodes]\n    yoffeeFragment.__expressions = expressions;\n    yoffeeFragment.__updateExpressions = () => updateExpressions(expressions.filter(ex => !ex.isStatic && !ex.isEventHandler))\n    yoffeeFragment.append(...containerElement.childNodes);\n    return yoffeeFragment\n}\n\n/**\n * Returns a DocumentFragment that has a one-way binding to each of the objects.\n * @param {...Object} propsObjects Holds the state of this yoffee element\n * @returns {function(*=, ...[*]): DocumentFragment}\n */\nfunction html(...propsObjects) {\n    // Set ID for new props objects, and add watcher to prop object\n    propsObjects.forEach(obj => {\n        if (typeof obj !== \"object\") {\n            throw `YOFFEE: Props object must be an object, got ${typeof propsObject}`\n        }\n        else if (obj == null) {\n            throw `YOFFEE: Props object can't be null`\n        }\n\n        if (obj[NoWatchProperty] == null) {\n            obj[NoWatchProperty] = randomId();\n            watch(\n                obj,\n                onGetListener,\n                onSetListener\n            );\n        }\n    });\n\n    // This is the tagged template literal function. It receives template strings and expressions in between.\n    return (strings, ...expressionCbs) => {\n        let createTemplate = () => createBoundDocumentFragment(propsObjects, strings, expressionCbs);\n\n        // If we're inside another yoffee template, we don't create a new template because it's possible it should be cached.\n        // Instead, we return callback to create the template, and info to determine if should be cached (hash, expressions, propsObjects)\n        if (isInsideExpression) {\n            let deferredTemplate = {\n                propsObjs: propsObjects,\n                expressionCbs: expressionCbs,\n                hash: hashTemplate(strings, expressionCbs),\n                cacheable: true,\n            }\n            deferredTemplate.createYoffeeTemplate = () => {\n                let t = createTemplate();\n                deferredTemplate.yoffeeTemplate = t;\n                return t\n            }\n            return deferredTemplate\n        }\n\n        return createTemplate();\n    }\n}\n\n\nexport {html, createYoffeeElement, YoffeeElement}\n"],"names":["YoffeeElement","HTMLElement","updateProp","attr","let","attrValue","this","getAttribute","props","constructor","state","super","attributes","forEach","name","MutationObserver","mutationsList","mutation","attributeName","propUpdatedCallback","observe","attachShadow","mode","_yoffeeFragment","render","shadowRoot","appendChild","disconnectedCallback","__removeWatchers","connectedCallback","createYoffeeElement","elementName","element","prototype","customElements","define","Function","renderCb","prop","onPropUpdate","onConnect","onDisconnect","objToListeners","Map","watch","object","onGet","onSet","listeners","get","set","propsHolder","wrapWithGetSet","propertyName","Object","defineProperty","value","properties","getOwnPropertyDescriptors","keys","setPrototypeOf","Proxy","target","Reflect","getset","push","SearchLocations","find","rootElement","searchValue","searcher","type","xpath","result","document","evaluate","XPathResult","FIRST_ORDERED_NODE_TYPE","singleNodeValue","domNode","searchLocation","fillStrWithExpressions","str","expressions","exp","replace","id","_cb","toString","randomId","Array","fill","map","Math","random","substr","join","addToListInMap","key","item","list","BoundNode","expressionsLocation","_arrayDomNodes","initialValue","data","ownerElement","update","_updateTextNodeValue","_updateAttributeNodeValue","_updateAttributeNodeName","newElement","oldDomNode","newTextNode","expression","cached","newValue","lastResult","_lastTextNodeValue","domNodeToRemove","_removeDomNode","DocumentFragment","childNodes","length","firstChild","listLocationMarker","createElement","replaceWith","newArrayDomNodes","currentElement","insert","parentNode","insertBefore","__isYoffee","__childNodes","nextSibling","oldElement","Text","shift","createTextNode","childNode","indexOf","Node","remove","isEventHandler","_setEventListener","isJustExpression","includes","setPropOnPotentialYoffeeElement","removeAttributeNode","_setDomNode","removeAttribute","setAttributeNode","_lastAttributeMap","attrName","_","removePropFromPotentialYoffeeElement","entries","setAttribute","newName","getAttributeNode","listenerName","eventName","substring","handleEvent","args","addEventListener","propName","propValue","arraysEqual","a","b","i","ExpResultTypes","Expression","expressionCb","boundNode","boundProps","Set","isStatic","resultType","resultMetadata","execute","newResult","createYoffeeTemplate","handleYoffeeTemplate","isArray","handleArray","removeChildTemplateListeners","deferredTemplate","hash","propsObjs","hash2","propsObjs2","yoffeeTemplate","cacheable","__expressions","index","expressionCbs","__updateExpressions","oldHashToTemplates","newHashToTemplates","listItem","cachedTemplatesList","cachedTemplateIndex","findIndex","t","cachedTemplate","splice","shouldntDelete","templateList","values","hashToTemplates","filter","_breakUpTextNodeToSmallerNodes","textNode","textToMakeNode","wholeText","trim","textStartIndex","textEndIndex","hashTemplate","strings","reduce","accu","current","split","charCodeAt","propsToExpressions","currentlySetProp","isInsideExpression","propsAlreadyAccessed","currentlyExecutingExpression","onGetListener","obj","__notWatchedProp","has","add","onSetListener","oldPropPlaceholder","expressionsToExecute","updateExpressions","exs","startRenderMidTree","oldIsInsideExpression","boundProp","delete","oldAlreadyAccessedProps","__propsAccessedByFather","oldCurrentlyExecutingExpression","ex","createBoundDocumentFragment","propsObjects","yoffeeFragment","createDocumentFragment","cb","arr1","containerElement","html","template","startsWith","innerHTML","content","firstElementChild","navigator","userAgent","toLowerCase","adoptNode","e","domNodeToBoundNode","searchResult","localName","append","propsObject","createTemplate"],"mappings":"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"}