{"version":3,"file":"yoffee.min.js","sources":["../src/YoffeeElement.js","../src/objectWatcher.js","../src/domNodeFinder.js","../src/utils.js","../src/boundNode.js","../src/expression.js","../src/yoffee.js"],"sourcesContent":["// Simple class to achieve React-like behaviour, while using web standards and Yoffee.js.\r\n// Technologies: CustomElements, ShadowRoot, MutationObserver, Attributes.\r\nclass YoffeeElement extends HTMLElement {\r\n    updateProp (attr) {\r\n        // There are two cases:\r\n        // 1. We are updating a regular attribute (a=3)\r\n        // 2. We are updating an object prop/attribute (a={something: 3}) that yoffee created. Attributes can't be\r\n        //    objects, so when an attribute is set with an object, yoffee sets the attribute to \"__obj_placeholder__\"\r\n        //    and sets a property on the element with the actual value.\r\n        let attrValue = (this[attr] === undefined ? this.getAttribute(attr) : this[attr]);\r\n        if (attrValue === \"\") {\r\n            this.props[attr] = true // When attribute values are not specified, they're true. Example: <div hidden></div>\r\n        } else {\r\n            this.props[attr] = attrValue\r\n        }\r\n    };\r\n\r\n    constructor(state) {\r\n        super();\r\n        // Yoffee can add 'props' property when element is not yet initialized, and we need to remember them.\r\n        this.props = this.props || {};\r\n        this.state = state || {};\r\n\r\n        // Put current attributes into props\r\n        [...this.attributes].forEach(attr => this.updateProp(attr.name));\r\n\r\n        // Observe the custom element for attribute changes using MutationObserver, and update the props\r\n        // Note: \"attributeChangedCallback\" is not good enough because it requires a static \"observedAttributes\", and\r\n        // we don't ask the user to declare his props beforehand\r\n        const addProp = mutationsList => mutationsList.forEach(mutation => {\r\n            this.updateProp(mutation.attributeName);\r\n            this.propUpdatedCallback && this.propUpdatedCallback(mutation.attributeName)\r\n        });\r\n        new MutationObserver(addProp).observe(this, {attributes: true});\r\n\r\n        // Add shadow DOM\r\n        this.attachShadow({mode: 'open'});\r\n\r\n        // Create yoffee template and append to custom element\r\n        this._yoffeeFragment = this.render();\r\n        this.shadowRoot.appendChild(this._yoffeeFragment)\r\n    }\r\n\r\n    disconnectedCallback() {\r\n        this._yoffeeFragment.__removeWatchers()\r\n    }\r\n\r\n    connectedCallback() {\r\n        // This is here for when users call `super.connectedCallback()`. Prevent the crash :)\r\n    }\r\n\r\n    propUpdatedCallback(prop) {\r\n        // This is here for when users call `super.propUpdatedCallback()`. Prevent the crash. :(\r\n    }\r\n}\r\n\r\nfunction createYoffeeElement(elementName, element) {\r\n    if (element.prototype instanceof YoffeeElement) {\r\n        // If we get a YoffeeElement, we just define it\r\n        customElements.define(elementName, element);\r\n    } else if (element instanceof Function) {\r\n        // If we get a cb, we wrap it with YoffeeElement\r\n        customElements.define(elementName, class extends YoffeeElement {\r\n            render() {\r\n                return element(\r\n                    this.props,\r\n                    this\r\n                )\r\n            }\r\n\r\n            propUpdatedCallback(prop) {\r\n                super.propUpdatedCallback(prop)\r\n                this.onPropUpdate && this.onPropUpdate(prop)\r\n            }\r\n\r\n            connectedCallback() {\r\n                super.connectedCallback()\r\n                this.onConnect && this.onConnect()\r\n            }\r\n\r\n            disconnectedCallback() {\r\n                super.disconnectedCallback();\r\n                this.onDisconnect && this.onDisconnect()\r\n            }\r\n        })\r\n    } else {\r\n        throw `YOFFEE: \\`createYoffeeElement\\` second parameter must be either a YoffeeElement subclass or a function, Got ${typeof renderCb}`\r\n    }\r\n}\r\n\r\nexport {YoffeeElement, createYoffeeElement};\r\n","// TODO: Make library.\r\n\r\nconst NoWatchProperty = \"__notWatchedProp\"\r\n\r\n/** @type {Map<Object, [{onGet: Function, onSet: Function}]>} */\r\nconst objToListeners = new Map();\r\n\r\n/**\r\n * Calls `onGet` and `onSet` each time a property is accessed / set.\r\n * It does so by wrapping the object with property accessors and proxying.\r\n * @param {Object} object\r\n * @param {Function} onGet\r\n * @param {Function} onSet\r\n */\r\nfunction watch(object, onGet, onSet) {\r\n    let listeners = objToListeners.get(object);\r\n    if (listeners == null) {\r\n        listeners = [{onGet, onSet}];\r\n        objToListeners.set(object, listeners);\r\n        watchObject(\r\n            object,\r\n            prop => listeners.forEach(getset => getset.onGet(prop, object)),\r\n            (prop, value) => listeners.forEach(getset => getset.onSet(prop, value, object))\r\n        )\r\n    } else {\r\n        listeners.push({onGet, onSet})\r\n    }\r\n}\r\n\r\nfunction removeWatcher(object, onGet, onSet) {\r\n    let listeners = objToListeners.get(object);\r\n    if (listeners != null) {\r\n        let index = listeners.findIndex(listener => listener.onGet === onGet && listener.onSet === onSet);\r\n        if (index !== -1) {\r\n            listeners.splice(index, 1)\r\n        }\r\n    }\r\n}\r\n\r\nfunction watchObject(object, onGet, onSet) {\r\n    const propsHolder = {};\r\n\r\n    const wrapWithGetSet = propertyName => {\r\n        Object.defineProperty(object, propertyName, {\r\n            get() {\r\n                onGet && onGet(propertyName);\r\n                return propsHolder[propertyName]\r\n            },\r\n            set(value) {\r\n                propsHolder[propertyName] = value;\r\n                onSet && onSet(propertyName, value);\r\n            }\r\n        });\r\n    };\r\n\r\n    // Wrap existing properties with getters & setters\r\n    const properties = Object.getOwnPropertyDescriptors(object);\r\n    for (let propertyName of Object.keys(properties)) {\r\n        if (propertyName === NoWatchProperty) {\r\n            continue\r\n        }\r\n        propsHolder[propertyName] = object[propertyName];\r\n        wrapWithGetSet(propertyName)\r\n    }\r\n\r\n    // Use proxy to intercept new properties\r\n    Object.setPrototypeOf(object, new Proxy(propsHolder, {\r\n        get(target, propertyName) {\r\n            // This is only called when trying to get non existing props.\r\n            wrapWithGetSet(propertyName);\r\n            Reflect.get(object, propertyName)\r\n        },\r\n        set(target, propertyName, value) {\r\n            wrapWithGetSet(propertyName);\r\n            object[propertyName] = value;\r\n            return true;\r\n        }\r\n    }));\r\n}\r\n\r\nexport {watch, removeWatcher, NoWatchProperty}\r\n","// TODO: make library\r\n\r\nconst SearchLocations = {\r\n    TEXT_NODE: \"Text/CSS node\",\r\n    ATTR_VALUE: \"Attribute value\",\r\n    ATTR_NAME: \"Attribute name\",\r\n    HTML_TAG: \"HTML tag\"\r\n};\r\n\r\n/**\r\n *\r\n * @param rootElement\r\n * @param searchValue\r\n * @returns {{domNode: Node, searchLocation: String} | null}\r\n */\r\nfunction find(rootElement, searchValue) {\r\n    const xpathSearchers = [\r\n        {\r\n            // Finds TextNode by text\r\n            type: SearchLocations.TEXT_NODE,\r\n            xpath: `.//text()[contains(., '${searchValue}')]`\r\n        }, {\r\n            // Finds Attribute by value\r\n            type: SearchLocations.ATTR_VALUE,\r\n            xpath: `.//@*[contains(., '${searchValue}')]`\r\n        }, {\r\n            // Finds Attribute by attribute's name\r\n            type: SearchLocations.ATTR_NAME,\r\n            xpath: `.//@*[contains(name(), '${searchValue}')]`\r\n        }, {\r\n            // Finds HTML elements by tag names\r\n            type: SearchLocations.HTML_TAG,\r\n            xpath: `.//*[contains(name(), '${searchValue}')]`\r\n        }\r\n    ];\r\n\r\n    for (let searcher of xpathSearchers) {\r\n        let result = document.evaluate(\r\n            searcher.xpath,\r\n            rootElement,\r\n            null, XPathResult.FIRST_ORDERED_NODE_TYPE, null\r\n        ).singleNodeValue;\r\n\r\n        if (result != null) {\r\n            return {\r\n                domNode: result,\r\n                searchLocation: searcher.type\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport {find, SearchLocations}\r\n","function fillStrWithExpressions(str, expressions) {\r\n    for (let exp of expressions) {\r\n        str = str.replace(exp.id, \"${\" + exp._cb.toString() + \"}\")\r\n    }\r\n    return str\r\n}\r\n\r\nfunction randomId() {\r\n    return new Array(4).fill(0).map(\r\n        () => Math.random().toString(36).substr(2, 9)).join(\"-\");\r\n}\r\n\r\nfunction addToListInMap(map, key, item) {\r\n    let list = map.get(key)\r\n    if (list != null) {\r\n        list.push(item)\r\n    } else {\r\n        map.set(key, [item])\r\n    }\r\n}\r\n\r\nfunction addToSetInMap(map, key, item) {\r\n    let list = map.get(key)\r\n    if (list != null) {\r\n        list.add(item)\r\n    } else {\r\n        map.set(key, new Set([item]))\r\n    }\r\n}\r\n\r\nfunction getLongestSubsequence(unordered) {\r\n    let rootNode = {\r\n        value: -999999999,\r\n        layer: 0,\r\n        parent: null,\r\n        index: null\r\n    };\r\n    let nodes = [rootNode];\r\n    for (let i = 0; i < unordered.length; i++) {\r\n        let orphan = unordered[i];\r\n        let adoptingFather = nodes[0];\r\n        for (let node of nodes) {\r\n            if (orphan > node.value && node.layer > adoptingFather.layer) {\r\n                adoptingFather = node;\r\n            }\r\n        }\r\n        nodes.push({\r\n            value: orphan,\r\n            layer: adoptingFather.layer + 1,\r\n            parent: adoptingFather,\r\n            index: i\r\n        });\r\n    }\r\n\r\n    let maxLayer = -1;\r\n    let bestNode = null;\r\n    for (let node of nodes) {\r\n        if (node.layer > maxLayer) {\r\n            bestNode = node;\r\n            maxLayer = node.layer;\r\n        }\r\n    }\r\n\r\n    let indices = [];\r\n    while(bestNode.parent !== null) {\r\n        indices.unshift(bestNode.index);\r\n        bestNode = bestNode.parent\r\n    }\r\n    return indices\r\n}\r\n\r\nexport {fillStrWithExpressions, randomId, addToListInMap, addToSetInMap, getLongestSubsequence}","import {SearchLocations} from \"./domNodeFinder.js\";\r\nimport {fillStrWithExpressions, getLongestSubsequence} from \"./utils.js\";\r\n\r\nclass BoundNode {\r\n    /**\r\n     * A single HTML node, containing all that's needed\r\n     * @param {[Expression]} expressions\r\n     * @param {HTMLElement} domNode\r\n     * @param {String} expressionsLocation\r\n     */\r\n    constructor(expressions, domNode, expressionsLocation) {\r\n        this.expressions = expressions;\r\n        this.domNode = domNode;\r\n        this.expressionsLocation = expressionsLocation;\r\n        this._arrayDomNodes = [];\r\n\r\n        /**\r\n         * @type String\r\n         * The value of the node before IDs were replaced with their values\r\n         */\r\n        this.initialValue = {\r\n            // TextNode content\r\n            [SearchLocations.TEXT_NODE]: () => domNode.data,\r\n            // Attribute value\r\n            [SearchLocations.ATTR_VALUE]: () => domNode.value,\r\n            // Attribute name\r\n            [SearchLocations.ATTR_NAME]: () => domNode.name,\r\n        }[expressionsLocation]();\r\n        this.ownerElement = this.domNode.ownerElement // The element that owns an AttributeNode\r\n    }\r\n\r\n    update() {\r\n        if (this.expressionsLocation === SearchLocations.TEXT_NODE) {\r\n            this._updateTextNodeValue()\r\n        } else if (this.expressionsLocation === SearchLocations.ATTR_VALUE) {\r\n            this._updateAttributeNodeValue()\r\n        } else if (this.expressionsLocation === SearchLocations.ATTR_NAME) {\r\n            this._updateAttributeNodeName()\r\n        }\r\n    }\r\n\r\n    _updateTextNodeValue() {\r\n        // Text nodes will always have one expression only, because we break up text node into smaller ones\r\n        let expression = this.expressions[0];\r\n\r\n        // Do not modify node with cached expression\r\n        if (expression.cached) {\r\n            return;\r\n        }\r\n\r\n        let newValue = expression.lastResult;\r\n\r\n        if (newValue == null || newValue === false) {\r\n            newValue = \"\"\r\n        }\r\n\r\n        // Remove old array\r\n        if (this._lastTextNodeValue instanceof Array && !(newValue instanceof Array)) {\r\n            // TODO: Keyed logic for performance: dont delete all, only changed keys\r\n            // Delete old array, make domNode the last remaining value\r\n            for (let domNodeToRemove of this._arrayDomNodes) {\r\n                this._removeDomNode(domNodeToRemove);\r\n            }\r\n            this._arrayDomNodes = [];\r\n        }\r\n\r\n        // Unpack documentFragment\r\n        if (newValue instanceof DocumentFragment) {\r\n            if (newValue.childNodes.length === 0) {\r\n                newValue = \"\";\r\n            } else if (newValue.childNodes.length === 1) {\r\n                newValue = newValue.firstChild;\r\n            } else {\r\n                newValue = [...newValue.childNodes];\r\n            }\r\n        }\r\n\r\n        // Insert new array\r\n        if (newValue instanceof Array) {\r\n            // Create location marker if there isn't\r\n            if (!(this._lastTextNodeValue instanceof Array)) {\r\n                let listLocationMarker = document.createElement(\"yoffee-list-location-marker\");\r\n                this.domNode.replaceWith(listLocationMarker);\r\n                this.domNode = listLocationMarker;\r\n            }\r\n\r\n            // We need to apply DOM diffing algorithm.\r\n\r\n            // TODO: REVIVE SMART ALGORITHM...!\r\n            // // Remember order of new elements\r\n            // let elementToIndex = new Map();\r\n            // for (let i = 0; i < newValue.length; i++) {\r\n            //     let newArrayElement = typeof newValue[i] === \"number\" ? newValue[i].toString() : newValue[i];\r\n            //     elementToIndex.set(newArrayElement, i)\r\n            // }\r\n            //\r\n            // // Delete old elements which are not in new element list\r\n            // let elementsOrder = [];\r\n            // this._arrayDomNodes = this._arrayDomNodes.filter(existingDomNode => {\r\n            //     // Text nodes should be checked by their content equality and not reference equality\r\n            //     let elementToCheck = existingDomNode instanceof Text ? existingDomNode.data : existingDomNode;\r\n            //\r\n            //     // Checking if existingDomNode is also in the new list\r\n            //     if (elementToIndex.has(elementToCheck)) {\r\n            //         elementsOrder.push(elementToIndex.get(elementToCheck));\r\n            //         return true;\r\n            //     }\r\n            //\r\n            //     // If not, we destroy it.\r\n            //     this._removeDomNode(existingDomNode);\r\n            // });\r\n            //\r\n            // // Find longest subsequence of elements which we will keep in DOM for performance\r\n            // let cachedIndicesInNewList = getLongestSubsequence(elementsOrder).map(index => elementsOrder[index]);\r\n            // let cachedElementsInNewList = cachedIndicesInNewList.map(i => typeof newValue[i] === \"number\" ? newValue[i].toString() : newValue[i])\r\n            //\r\n            // // Remove old elements from dom which aren't ordered (later we insert them at the right index)\r\n            // this._arrayDomNodes = this._arrayDomNodes.filter((existingDomNode, index) => {\r\n            //     let elementToCheck = existingDomNode instanceof Text ? existingDomNode.data : existingDomNode;\r\n            //     if (!cachedElementsInNewList.includes(elementToCheck)) {\r\n            //         this._removeDomNode(existingDomNode);\r\n            //         return false\r\n            //     }\r\n            //     return true\r\n            // });\r\n            //\r\n            // // Now we insert all new elements except those that already exist in remainingOldIndices\r\n            // let indexOfNextRemaining = 0;\r\n            // let nextRemainingElement = this._arrayDomNodes[0];\r\n            // let nextArrayDomNodes = [];\r\n            // let insert = element => {\r\n            //     if (nextRemainingElement == null) {\r\n            //         this.domNode.parentNode.insertBefore(element, this.domNode)\r\n            //     } else {\r\n            //         this.domNode.parentNode.insertBefore(element, nextRemainingElement)\r\n            //     }\r\n            // }\r\n            //\r\n            // for (let i = 0; i < newValue.length; i++) {\r\n            //     if (i === cachedIndicesInNewList[indexOfNextRemaining]) {\r\n            //         nextArrayDomNodes.push(this._arrayDomNodes[indexOfNextRemaining]);\r\n            //         if (indexOfNextRemaining < cachedIndicesInNewList.length) {\r\n            //             indexOfNextRemaining += 1;\r\n            //             nextRemainingElement = this._arrayDomNodes[indexOfNextRemaining];\r\n            //         }\r\n            //     } else {\r\n            //         let arrayValue = newValue[i];\r\n            //         arrayValue = typeof arrayValue === \"object\" ? arrayValue : document.createTextNode(arrayValue)\r\n            //         nextArrayDomNodes.push(arrayValue);\r\n            //\r\n            //         if (arrayValue.__isYoffee) {\r\n            //             for (let childNode of arrayValue.__childNodes) {\r\n            //                 insert(childNode);\r\n            //             }\r\n            //         } else {\r\n            //             insert(arrayValue);\r\n            //         }\r\n            //     }\r\n            // }\r\n            // this._arrayDomNodes = nextArrayDomNodes;\r\n\r\n            let newArrayDomNodes = [];\r\n            let currentElement = null;\r\n            let insert = element => {\r\n                // If the first element is inserted before cached elements, it should be inserted before the first old\r\n                // element in the list. If there are none, it would be just inserted before the list marker\r\n                if (currentElement == null) {\r\n                    if (this._arrayDomNodes[0] == null) {\r\n                        this.domNode.parentNode.insertBefore(element, this.domNode)\r\n                    } else {\r\n                        this.domNode.parentNode.insertBefore(\r\n                            element,\r\n                            (this._arrayDomNodes[0].__isYoffee ? this._arrayDomNodes[0].__childNodes[0] : this._arrayDomNodes[0])\r\n                        )\r\n                    }\r\n                } else {\r\n                    // Here we insert element in the middle of the list, after currentElement\r\n                    this.domNode.parentNode.insertBefore(\r\n                        element,\r\n                        currentElement.nextSibling\r\n                    )\r\n                }\r\n                currentElement = element.__isYoffee ? element.__childNodes[element.__childNodes.length - 1] : element;\r\n            }\r\n\r\n            for (let newElement of newValue) {\r\n                if (newElement == null) {\r\n                    continue\r\n                }\r\n\r\n                let oldElement = this._arrayDomNodes[0];\r\n                if (oldElement != null &&\r\n                    (oldElement instanceof Text ? oldElement.data : oldElement) ===\r\n                    (typeof newElement === \"number\" ? newElement.toString() : newElement)\r\n                ) {\r\n                    newArrayDomNodes.push(oldElement);\r\n                    currentElement = oldElement.__isYoffee ?\r\n                        oldElement.__childNodes[oldElement.__childNodes.length - 1] : oldElement;\r\n                    this._arrayDomNodes.shift();\r\n                } else {\r\n                    newElement = typeof newElement === \"object\" ? newElement : document.createTextNode(newElement)\r\n                    newArrayDomNodes.push(newElement);\r\n\r\n                    if (newElement.__isYoffee) {\r\n                        // The reason we keep yoffee documentFragments in _arrayDomNodes is because of caching\r\n                        for (let childNode of newElement.__childNodes) {\r\n                            insert(childNode);\r\n                        }\r\n                    } else if (newElement instanceof Array) {\r\n                        // TODO: Why not, actually???????????????????????????????????\r\n                        throw \"YOFFEE: List item cannot be another list\"\r\n                    } else {\r\n                        insert(newElement);\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (let oldDomNode of this._arrayDomNodes) {\r\n                if (newArrayDomNodes.indexOf(oldDomNode) === -1) {\r\n                    this._removeDomNode(oldDomNode);\r\n                }\r\n            }\r\n\r\n            this._arrayDomNodes = newArrayDomNodes;\r\n        } else if (typeof newValue === \"object\") {\r\n            // Either element or object. If object, wat do we do??\r\n            // TODO: WAT DO WE DO?\r\n            if (!(newValue instanceof Node)) {\r\n                throw \"YOFFEE: Text value can't be a regular JS object!\"\r\n            }\r\n            this.domNode.replaceWith(newValue);\r\n            this.domNode = newValue;\r\n        } else {\r\n            // TODO: If value is same as last, don't replace. just let it beef\r\n            if (typeof this._lastTextNodeValue === \"object\") {\r\n                // Replace old object/list with string\r\n                let newTextNode = document.createTextNode(newValue);\r\n                this.domNode.replaceWith(newTextNode);\r\n                this.domNode = newTextNode;\r\n            } else {\r\n                // If just string\r\n                if (this.domNode.data !== newValue.toString()) {\r\n                    this.domNode.data = newValue;\r\n                }\r\n            }\r\n        }\r\n\r\n        this._lastTextNodeValue = newValue;\r\n    }\r\n\r\n    _removeDomNode(domNode) {\r\n        // If domNode is __isYoffee, kill all children because it's a DocumentFragment. Note: checking for\r\n        // DocumentFragments would be wrong, because we never store DocumentFragments which aren't yoffee\r\n        // template in `this._arrayDomNodes`.\r\n        if (domNode.__isYoffee) {\r\n            for (let childNode of domNode.__childNodes) {\r\n                childNode.remove();\r\n            }\r\n        } else {\r\n            domNode.remove()\r\n        }\r\n    }\r\n\r\n    _updateAttributeNodeValue() {\r\n        // Checks if expression is an event handler, and adds an event listener if true.\r\n        if (this.expressions[0].isEventHandler) {\r\n            if (this.expressions.length > 1) {\r\n                let forbiddenEventHandlerText = fillStrWithExpressions(this.initialValue, this.expressions);\r\n                throw `YOFFEE: Cant have more than one expression as event handler: ${forbiddenEventHandlerText}`\r\n            }\r\n            this._setEventListener();\r\n        } else {\r\n            let lastResult = this.expressions[0].lastResult;\r\n\r\n            // Check if there is only one expression, and no fixed text as well (by comparing the expression length)\r\n            let isJustExpression = this.expressions.length === 1 && this.initialValue.length === this.expressions[0].id.length;\r\n\r\n            if (isJustExpression && (lastResult === false || lastResult == null)) {\r\n                // If value is falsy, remove the attribute\r\n                this.ownerElement[this.domNode.name] = undefined;\r\n                this.ownerElement.removeAttribute(this.domNode.name);\r\n            } else if (isJustExpression && [\"function\", \"object\"].includes(typeof lastResult)) {\r\n                // If attr value is function or object, set it directly as a property of the element instead of\r\n                // attribute, because attributes can only hold strings\r\n                setPropOnPotentialYoffeeElement(this.ownerElement, this.domNode.name, lastResult)\r\n\r\n                // Remove the attribute (First check if we already removed it before)\r\n                if (this.domNode.ownerElement != null) {\r\n                    this.domNode.ownerElement.removeAttributeNode(this.domNode);\r\n                }\r\n            } else if (isJustExpression && lastResult === true) {\r\n                // If we get true, just set the attribute with no value (<div a></div>)\r\n                this.ownerElement[this.domNode.name] = undefined;\r\n                this._setDomNode(\"\");\r\n            } else {\r\n                // Has to be done before setDomNode\r\n                this.ownerElement[this.domNode.name] = undefined;\r\n\r\n                // If string, replaces original value ids with expression values\r\n                let newValue = this.initialValue;\r\n                for (let expression of this.expressions) {\r\n                    newValue = newValue.replace(expression.id, expression.lastResult)\r\n                }\r\n                this._setDomNode(newValue);\r\n            }\r\n        }\r\n    }\r\n\r\n    _setDomNode(value) {\r\n        this.domNode.value = value;\r\n        if (this.domNode.ownerElement == null) {\r\n            this.ownerElement.setAttributeNode(this.domNode)\r\n        }\r\n    }\r\n\r\n    _updateAttributeNodeName() {\r\n        let lastResult = this.expressions[0].lastResult;\r\n        let isJustExpression = this.expressions.length === 1 && this.initialValue.length === this.expressions[0].id.length;\r\n\r\n        // Because changing an attribute name is impossible, we must remove the attributes and creates new ones with updated names\r\n        if (this._lastAttributeMap) {\r\n            // Removes last attribute mapping if there was\r\n            // TODO: Dont remove all, replace only different ones...\r\n            for (let [attrName, _] of this._lastAttributeMap) {\r\n                this.ownerElement.removeAttribute(attrName);\r\n                removePropFromPotentialYoffeeElement(this.ownerElement, attrName)\r\n            }\r\n            this._lastAttributeMap = null\r\n        } else {\r\n            // Removes last attribute\r\n            // TODO: Dont remove if they're same\r\n            this.ownerElement.removeAttribute(this.domNode.name)\r\n        }\r\n\r\n        if (isJustExpression && (lastResult === false || lastResult == null || lastResult === \"\")) {\r\n            // Don't add any attribute if value is falsy\r\n            return\r\n        }\r\n\r\n        if (isJustExpression && typeof lastResult === \"object\") {\r\n            // If we get an object, insert it as key-value mapping of attributes\r\n            this._lastAttributeMap = Object.entries(lastResult)\r\n            for (let [attrName, value] of this._lastAttributeMap) {\r\n                if (value !== false && value !== null) {\r\n                    if ([\"function\", \"object\"].includes(typeof value)) {\r\n                        // this.ownerElement.setAttribute(attrName, \"__obj_placeholder__\");\r\n                        // this.ownerElement[attrName] = value\r\n\r\n                        setPropOnPotentialYoffeeElement(this.ownerElement, attrName, value)\r\n\r\n                        // Remove the attribute (First check if we already removed it before)\r\n                        if (this.domNode.ownerElement != null) {\r\n                            this.domNode.ownerElement.removeAttributeNode(this.domNode);\r\n                        }\r\n\r\n                    } else {\r\n                        if (value === true) {\r\n                            value = \"\"\r\n                        }\r\n                        this.ownerElement.setAttribute(attrName, value);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            // If string, replaces ids with expression values\r\n            let newName = this.initialValue;\r\n            for (let expression of this.expressions) {\r\n                newName = newName.replace(expression.id, expression.lastResult)\r\n            }\r\n\r\n            this.ownerElement.setAttribute(newName, this.domNode.value);\r\n            this.domNode = this.ownerElement.getAttributeNode(newName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Replaces attribute node that starts with \"on\" with event listener.\r\n     * This will never run twice on the same expression, because no props are linked, because event handler expressions\r\n     * don't evaluate until the event is caught.\r\n     * @private\r\n     */\r\n    _setEventListener() {\r\n        let listenerName = this.domNode.name; // For example, 'onclick'\r\n        let eventName = listenerName.substring(2); // Remove the `on` from `onclick`\r\n\r\n        // The function that will handle both the event and the callback function property\r\n        let handleEvent = (...args) => {\r\n            const result = this.expressions[0].lastResult(...args);\r\n\r\n            // In case expression returns another function (user wrote ${() => () => print(\"stuff)} for example)\r\n            if (typeof result === \"function\") {\r\n                return result(...args)\r\n            }\r\n\r\n            // TODO: If user returned a string (onclick=\"${() => state.wat ? \"alert(1)\" : \"alert(2)}\") we should eval that\r\n            return result\r\n        }\r\n\r\n        // TODO: Remove event listener when the value changes!!! (like the attribute being deleted, then added again?)\r\n        // Setting event listener\r\n        this.domNode.ownerElement.addEventListener(eventName, handleEvent);\r\n\r\n        // Adding callback function property as well\r\n        setPropOnPotentialYoffeeElement(this.domNode.ownerElement, listenerName, handleEvent)\r\n\r\n        // Remove the attribute\r\n        this.domNode.ownerElement.removeAttributeNode(this.domNode);\r\n    }\r\n}\r\n\r\nfunction setPropOnPotentialYoffeeElement(element, propName, propValue) {\r\n    // First, setting property on element\r\n    element[propName] = propValue\r\n\r\n    // Checking if element is initialized or still an UnknownHTMLElement. If initilized, call `updateProp`\r\n    if (element.updateProp) {\r\n        element.updateProp(propName)\r\n    } else {\r\n        // If not initialized, keep everything in props until it is initialized\r\n        if (element.props == null) {\r\n            element.props = {}\r\n        }\r\n        element.props[propName] = propValue\r\n    }\r\n}\r\n\r\nfunction removePropFromPotentialYoffeeElement(element, propName) {\r\n    // First, setting property on element\r\n    element[propName] = undefined\r\n\r\n    // Checking if element is initialized or still an UnknownHTMLElement. If initilized, call `updateProp`\r\n    if (element.updateProp) {\r\n        element.updateProp(propName)\r\n    } else {\r\n        // If not initialized, keep everything in props until it is initialized\r\n        if (element.props == null) {\r\n            element.props = {}\r\n        }\r\n        element.props[propName] = undefined\r\n    }\r\n}\r\n\r\nexport {BoundNode}","import {randomId, addToListInMap} from \"./utils.js\";\r\n\r\nfunction arraysEqual(a, b) {\r\n    if (a.length !== b.length) return false;\r\n\r\n    for (let i = 0; i < a.length; ++i) {\r\n        if (a[i] !== b[i]) return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction isHashSame(hash, propsObjs, hash2, propsObjs2) {\r\n    return hash === hash2 && arraysEqual(propsObjs, propsObjs2)\r\n}\r\n\r\nfunction mutationFilter(arr, cb) {\r\n    for (let i = arr.length - 1; i >= 0; i -= 1) {\r\n        if (!cb(arr[i])) {\r\n            arr.splice(i, 1)\r\n        }\r\n    }\r\n}\r\n\r\nconst ExpResultTypes = {\r\n    PRIMITIVE: \"primitive\",\r\n    ARRAY: \"array\",\r\n    YOFFEE_TEMPLATE: \"yoffee_template\"\r\n}\r\n\r\nclass Expression {\r\n    constructor(expressionCb) {\r\n        this._cb = expressionCb;\r\n        this.id = randomId();\r\n        this.lastResult = null;\r\n        this.boundNode = null;\r\n        this.boundProps = new Set()\r\n        this.isEventHandler = false;\r\n        this.isStatic = (typeof this._cb) !== \"function\";\r\n\r\n        this.resultType = null;\r\n        this.resultMetadata = null;\r\n    }\r\n\r\n    execute() {\r\n        // Resetting cached state\r\n        this.cached = false;\r\n\r\n        if (this.isEventHandler || this.isStatic) {\r\n            this.lastResult = this._cb;\r\n        } else {\r\n            let newResult = this._cb();\r\n\r\n            // Checks if the output is a yoffee template\r\n            if (newResult != null && newResult.createYoffeeTemplate) {\r\n                this.handleYoffeeTemplate(newResult);\r\n            } else if (Array.isArray(newResult)) {\r\n                this.handleArray(newResult);\r\n            // } else if (typeof newResult === \"object\" && newResult != null) {\r\n            //     this.handleKeyedList(newResult)\r\n            } else {\r\n                // Primitive value - just setting it and destroying all children\r\n                this.removeChildTemplateListeners();\r\n                this.lastResult = newResult;\r\n                this.resultType = ExpResultTypes.PRIMITIVE;\r\n                this.resultMetadata = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    handleYoffeeTemplate(deferredTemplate) {\r\n        // In case we are recursive\r\n        if (this.resultType === ExpResultTypes.YOFFEE_TEMPLATE &&\r\n            this.resultMetadata.yoffeeTemplate == null) {\r\n            return\r\n        }\r\n\r\n        // Check if new template is the same as the last\r\n        if (this.resultType === ExpResultTypes.YOFFEE_TEMPLATE &&\r\n            // !this.resultMetadata.yoffeeTemplate.__contentChanged &&\r\n            // !this.resultMetadata.yoffeeTemplate.__weaklyBoundProps.has(TemplateStack.getCurrentlySetProp()) &&\r\n            this.resultMetadata.cacheable &&\r\n            isHashSame(this.resultMetadata.hash, this.resultMetadata.propsObjs, deferredTemplate.hash, deferredTemplate.propsObjs)\r\n        ) {\r\n            // Caching template\r\n            console.log(\"Using cached template\")\r\n            this.cached = true;\r\n            this.lastResult.__expressions.forEach((exp, index) => {\r\n                exp._cb = deferredTemplate.expressionCbs[index];\r\n            })\r\n            this.lastResult.__updateExpressions();\r\n        } else {\r\n            // Destroy all past yoffee children\r\n            this.removeChildTemplateListeners()\r\n\r\n            this.resultType = ExpResultTypes.YOFFEE_TEMPLATE;\r\n            this.resultMetadata = deferredTemplate\r\n            this.lastResult = deferredTemplate.createYoffeeTemplate();\r\n        }\r\n    }\r\n\r\n    handleArray(newResult) {\r\n        // Check if last result was an array, and cache existing yoffees\r\n        if (this.resultType === ExpResultTypes.ARRAY) {\r\n            let oldHashToTemplates = this.resultMetadata;\r\n\r\n            // // Filter out and remove watchers for yoffees with a changed content\r\n            // for (let templateList of oldHashToTemplates.values()) {\r\n            //     mutationFilter(templateList, t => {\r\n            //         // if (t.yoffeeTemplate.__contentChanged) {\r\n            //         if (t.yoffeeTemplate != null\r\n            //             && t.yoffeeTemplate.__weaklyBoundProps.has(TemplateStack.getCurrentlySetProp())\r\n            //         ) {\r\n            //             t.yoffeeTemplate.__removeWatchers();\r\n            //             return false\r\n            //         }\r\n            //         return true\r\n            //     });\r\n            // }\r\n\r\n            // Populate array with new and old values\r\n            this.lastResult = [];\r\n            let newHashToTemplates = new Map();\r\n\r\n            // Important to override resultMetadata here, because next code can call createYoffeeTemplate recursively\r\n            this.resultMetadata = newHashToTemplates;\r\n\r\n            for (let listItem of newResult) {\r\n                if (listItem != null && listItem.createYoffeeTemplate) {\r\n                    let cached = false;\r\n\r\n                    // Find old template with same hash and props objects\r\n                    let cachedTemplatesList = oldHashToTemplates.get(listItem.hash);\r\n                    if (cachedTemplatesList != null && listItem.cacheable) {\r\n                        // Finds templates with the same prop objects as the new one\r\n                        let cachedTemplateIndex = cachedTemplatesList.findIndex(\r\n                            t => arraysEqual(t.propsObjs, listItem.propsObjs)\r\n                        );\r\n                        if (cachedTemplateIndex !== -1) {\r\n                            // We must splice because we can't reuse one old template for multiple new templates!\r\n                            let cachedTemplate = cachedTemplatesList.splice(cachedTemplateIndex, 1)[0];\r\n                            cached = true\r\n\r\n                            // TODO: Do we need the if???\r\n                            // if (cachedTemplate.yoffeeTemplate != null) {\r\n\r\n                            console.log(\"Using cached template in list\")\r\n                            this.lastResult.push(cachedTemplate.yoffeeTemplate);\r\n                            cachedTemplate.shouldntDelete = true\r\n\r\n                            cachedTemplate.yoffeeTemplate.__expressions.forEach((exp, index) => {\r\n                                exp._cb = listItem.expressionCbs[index];\r\n                            })\r\n                            cachedTemplate.yoffeeTemplate.__updateExpressions();\r\n                            // }\r\n\r\n                            addToListInMap(newHashToTemplates, cachedTemplate.hash, cachedTemplate);\r\n                        }\r\n                    }\r\n\r\n                    // Old wasn't found, creating new\r\n                    if (!cached) {\r\n                        addToListInMap(newHashToTemplates, listItem.hash, listItem);\r\n                        let yoffeeTemplate = listItem.createYoffeeTemplate()\r\n                        this.lastResult.push(yoffeeTemplate);\r\n                    }\r\n                } else {\r\n                    this.lastResult.push(listItem)\r\n                }\r\n            }\r\n\r\n            // Delete old uncached yoffees\r\n            for (let templateList of oldHashToTemplates.values()) {\r\n                templateList.forEach(t => {\r\n                    if (!t.shouldntDelete) {\r\n                        t.yoffeeTemplate.__removeWatchers();\r\n                    }\r\n                });\r\n            }\r\n            for (let templateList of newHashToTemplates.values()) {\r\n                templateList.forEach(t => {\r\n                    if (t.shouldntDelete) {\r\n                        t.shouldntDelete = undefined\r\n                    }\r\n                });\r\n            }\r\n        } else {\r\n            // First array render: if last result wasn't array\r\n            this.removeChildTemplateListeners();\r\n\r\n            this.lastResult = [];\r\n            let hashToTemplates = new Map();\r\n            for (let item of newResult) {\r\n                if (item != null && item.createYoffeeTemplate) {\r\n                    let yoffeeTemplate = item.createYoffeeTemplate()\r\n                    this.lastResult.push(yoffeeTemplate)\r\n                    addToListInMap(hashToTemplates, item.hash, item);\r\n                } else {\r\n                    this.lastResult.push(item)\r\n                }\r\n            }\r\n\r\n            this.resultMetadata = hashToTemplates;\r\n        }\r\n        this.resultType = ExpResultTypes.ARRAY;\r\n    }\r\n\r\n    removeChildTemplateListeners() {\r\n        if (this.resultType == null) {\r\n            return\r\n        }\r\n\r\n        if (this.resultType === ExpResultTypes.YOFFEE_TEMPLATE) {\r\n            this.resultMetadata.yoffeeTemplate.__removeWatchers();\r\n        } else if (this.resultType === ExpResultTypes.ARRAY) {\r\n            this.lastResult.filter(item => item.__isYoffee).forEach(yoffeeTemplate => yoffeeTemplate.__removeWatchers());\r\n        }\r\n    }\r\n}\r\n\r\nexport {Expression}","import {YoffeeElement, createYoffeeElement} from \"./YoffeeElement.js\"\r\nimport {watch, removeWatcher, NoWatchProperty} from \"./objectWatcher.js\"\r\nimport {find, SearchLocations} from \"./domNodeFinder.js\"\r\nimport {randomId, fillStrWithExpressions} from \"./utils.js\";\r\nimport {BoundNode} from \"./boundNode.js\";\r\nimport {Expression} from \"./expression.js\";\r\n\r\nfunction _joinTemplateStrings(arr1, arr2) {\r\n    return arr2.reduce((accu, current, i) => accu + current + arr1[i + 1], arr1[0])\r\n}\r\n\r\n/**\r\n * Creates an HTML element from html string.\r\n * We use template tag, because it doesn't render its content. The `content` property of the template element is a\r\n * DocumentFragment that contains all the elements under that template.\r\n * The reason we create an enclosing <yoffee-template-container> element and don't return the DocumentFragment directly,\r\n * is that document.evaluate can't run on a DocumentFragment, only on an element. So we enclose the template's content\r\n * with <yoffee-template-container>, and return that.\r\n * @param {String} html\r\n * @returns {Element}\r\n * @private\r\n */\r\nfunction _createContainerElement(html) {\r\n    let template = document.createElement(\"template\");\r\n\r\n    // yoffee-template-container doesn't exist, I made it up. It is an HTMLUnknownElement:\r\n    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLUnknownElement\r\n    html = html.trim();\r\n    let containerElement;\r\n\r\n    if ((html.startsWith(\"<tr\") || html.startsWith(\"<td\")) && (html[3] === \" \" || html[3] === \">\")) {\r\n        // // This works for creating the tr/td, but the real problem is that the expression itself is outside the table\r\n        // // because table can't contain stuff that's not legit content\r\n        // template.innerHTML = html;\r\n        //\r\n        // let template2 = document.createElement(\"template\");\r\n        // template2.innerHTML = \"<yoffee-template-container></yoffee-template-container>\"\r\n        // for (let child of template.content.children) {\r\n        //     template2.content.firstElementChild.appendChild(child)\r\n        // }\r\n        //\r\n        // containerElement = template2.content.firstElementChild;\r\n        throw `YOFFEE: Table tag is not supported`\r\n    } else {\r\n        template.innerHTML = `<yoffee-template-container>${html}</yoffee-template-container>`;\r\n        containerElement = template.content.firstElementChild;\r\n    }\r\n\r\n    // Firefox can't use document.evaluate on a node that's not under the document\r\n    if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {\r\n        // TODO: Check if you can use XMLDocument.evaluate to evaluate instead of adding to the DOM\r\n        return document.adoptNode(containerElement)\r\n    }\r\n    return containerElement\r\n}\r\n\r\n/**\r\n * Receives a textNode and divider (`textToMakeNode`), and breaks up the textNode into 3 textNodes: before, after and\r\n * middle, and returns the middle. The middle is the part that's equal to `textToMakeNode` and its value is changed to it.\r\n * the other parts are inserted into the DOM.\r\n * Example: node \"123\" with divider \"2\" will return insert \"1\" and \"3\" into the DOM, and return \"2\".\r\n * node \"23\" with divider \"2\" will insert \"3\" into DOM and return \"2\".\r\n * @param {Text} textNode\r\n * @param {String} textToMakeNode\r\n * @returns {Text}\r\n * @private\r\n */\r\nfunction _breakUpTextNodeToSmallerNodes(textNode, textToMakeNode) {\r\n    let wholeText = textNode.data.trim();\r\n    let textStartIndex = wholeText.indexOf(textToMakeNode);\r\n    let textEndIndex = textStartIndex + textToMakeNode.length;\r\n\r\n    // Insert node before\r\n    if (textStartIndex !== 0) {\r\n        textNode.parentNode.insertBefore(\r\n            document.createTextNode(wholeText.substring(0, textStartIndex)),\r\n            textNode\r\n        );\r\n    }\r\n\r\n    // Insert node after\r\n    if (textEndIndex < wholeText.length) {\r\n        textNode.parentNode.insertBefore(\r\n            document.createTextNode(wholeText.substring(textEndIndex)),\r\n            textNode.nextSibling\r\n        );\r\n    }\r\n\r\n    textNode.data = wholeText.substring(textStartIndex, textEndIndex);\r\n    return textNode;\r\n}\r\n\r\n/**\r\n * Creates BoundNodes from expressionIds inside `containerElement`.\r\n * Basically, we run over each expression and find it's ID inside the `containerElement`. It should be there somewhere.\r\n * For each ID we found we create a BoundNode, with the node that contains the ID and the expression.\r\n * Each BoundNode references a list of expressions, and each expression has a reference to its bound node.\r\n * @param {HTMLElement} containerElement\r\n * @param {[Expression]} expressions\r\n * @private\r\n */\r\nfunction bindNodesToExpressions(containerElement, expressions) {\r\n    /** @type {Map<Node, BoundNode>} */\r\n    const domNodeToBoundNode = new Map();\r\n\r\n    for (let expression of expressions) {\r\n        let searchResult = null;\r\n        searchResult = find(containerElement, expression.id);\r\n\r\n        if (searchResult == null) {\r\n            throw `YOFFEE: Expression location is not valid: ${\"${\" + expression._cb.toString() + \"}\"}`\r\n        }\r\n        let {domNode, searchLocation} = searchResult;\r\n\r\n        // Break up textNode\r\n        if (searchLocation === SearchLocations.TEXT_NODE) {\r\n            domNode = _breakUpTextNodeToSmallerNodes(domNode, expression.id)\r\n        }\r\n\r\n        // If template is inside html tag name, throw exception\r\n        if (searchLocation === SearchLocations.HTML_TAG) {\r\n            let forbiddenTagText = fillStrWithExpressions(`<${domNode.localName}>`, [expression]);\r\n            throw `YOFFEE: Calculating element name is not allowed: ${forbiddenTagText}`\r\n        }\r\n\r\n        // Expressions on attrs that start with \"on\" are event handlers\r\n        if (searchLocation === SearchLocations.ATTR_VALUE && domNode.name.startsWith(\"on\")) {\r\n            expression.isEventHandler = true;\r\n        }\r\n\r\n        // Create BoundNodes, deduping nodes that are found multiple times because of multiple expressions (attr node)\r\n        if (domNodeToBoundNode.has(domNode)) {\r\n            let boundNode = domNodeToBoundNode.get(domNode);\r\n            boundNode.expressions.push(expression);\r\n            expression.boundNode = boundNode;\r\n        } else {\r\n            let boundNode = new BoundNode([expression], domNode, searchLocation);\r\n            domNodeToBoundNode.set(domNode, boundNode);\r\n            expression.boundNode = boundNode;\r\n        }\r\n    }\r\n\r\n    // console.log(\"DomNodes + Expressions: \");\r\n    // console.log([...domNodeToBoundNode.values()]);\r\n}\r\n\r\nfunction hashTemplate(strings, expressionCbs) {\r\n    // Just zip two lists\r\n    // TODO: concatenating may cause a false equality. for example, \"<div>${()=>a}\" will be the same as \"<div>()=>${a}\"\r\n    let str = expressionCbs.reduce((accu, current, i) => accu + current + strings[i + 1], strings[0]);\r\n\r\n    // Hash result\r\n    return str.split(\"\").reduce(function (a, b) {\r\n        a = ((a << 5) - a) + b.charCodeAt(0);\r\n        return a & a\r\n    }, 0);\r\n}\r\n\r\n\r\n/** @type {Map<String, Set<Expression>>} */\r\nlet propsToExpressions = new Map();\r\n\r\n// TODO: Remove this.?\r\nlet currentlySetProp = null;\r\n\r\n/** @type {Boolean} */\r\nlet isInsideExpression = false;\r\n\r\n/**\r\n * Contains a set of props that were accessed so far when executing chain of expressions. This is important, because\r\n * if parent expressions accessed prop A and then his child expression also accessed it, child shouldn't rerender;\r\n * only parent should, and parent will execute his children himself.\r\n * @type {Set<String>}\r\n */\r\nlet propsAlreadyAccessed = new Set();\r\n\r\n/** @type {Expression} */\r\nlet currentlyExecutingExpression = null;\r\n\r\n\r\n/**\r\n * Called when any property was accessed on any prop object.\r\n * Responsible for:\r\n *  - Linking props to expressions in which they were accessed\r\n *  - Accumulating props that were accessed in expression chain\r\n *  - Updating list of `boundProps` on the current executing expression\r\n * @param {String} key\r\n * @param {Object} obj\r\n */\r\nlet onGetListener = (key, obj) => {\r\n    if (!isInsideExpression) {\r\n        return\r\n    }\r\n\r\n    // We use the props object's ID as prefix because the same prop in different props objects has to be different\r\n    let prop = `${obj[NoWatchProperty]}.${key}`;\r\n\r\n    // We accumulate props that were already accessed when executing chain of expressions.\r\n    // If prop wasn't accessed earlier, we count it in `propsAlreadyAccessed`, and add it to the list of boundProps\r\n    // on the current executing expression.\r\n    // If prop was accessed earlier in the expression chain, we don't attribute it to anything.\r\n    if (!propsAlreadyAccessed.has(prop)) {\r\n        propsAlreadyAccessed.add(prop);\r\n        currentlyExecutingExpression.boundProps.add(prop);\r\n        if (!propsToExpressions.has(prop)) {\r\n            propsToExpressions.set(prop, new Set());\r\n        }\r\n        propsToExpressions.get(prop).add(currentlyExecutingExpression);\r\n    }\r\n}\r\n\r\n/**\r\n * Called when any property is set on any props object.\r\n * Collects expressions which are linked to the updated property, and executes them. simple and stupid.\r\n * @param {String} key\r\n * @param value\r\n * @param {Object} obj\r\n */\r\nlet onSetListener = (key, value, obj) => {\r\n    if (isInsideExpression) {\r\n        throw `YOFFEE: Setting properties is not allowed inside an expression! (${key} = ${value})`\r\n    }\r\n\r\n    // TODO: Check if value is different than the current one, and spare expression evaluations\r\n    // We use the props object's ID as prefix because the same prop in different props objects has to be different\r\n    let prop = `${obj[NoWatchProperty]}.${key}`;\r\n\r\n    // The currently set prop is for when setting prop INSIDE an expression!\r\n    // TODO: Remove this. it doesnt do anything now\r\n    let oldPropPlaceholder = currentlySetProp;\r\n    currentlySetProp = prop;\r\n\r\n    // Collect expressions to execute (expressions that have props that were modified)\r\n    let expressionsToExecute = propsToExpressions.get(currentlySetProp);\r\n    if (expressionsToExecute == null) {\r\n        // TODO: Consider removing this warning. if one object has many yoffee elements it will happen annoyingly.\r\n        console.warn(`A prop changed but no expression is linked to it: ${\r\n            currentlySetProp.substr(currentlySetProp.indexOf(\".\") + 1)}`);\r\n        return;\r\n    }\r\n    updateExpressions([...expressionsToExecute], true)\r\n\r\n    currentlySetProp = oldPropPlaceholder;\r\n}\r\n\r\n/**\r\n * Receives a list of expressions, and executes them, updating the template afterwards.\r\n * This function is running in a recursive manner. It doesn't call itself, but expressions call it when they need to\r\n * execute child expressions. That's why we use 'old' parameters, like 'oldIsInsideExpression', to set back the global\r\n * value to what it was before function was called recursively.\r\n * @param {[Expression]} exs Expressions to execute\r\n * @param {Boolean?} startRenderMidTree If we're starting render mid-tree (when setting prop), we should remember\r\n * accessed props of ancestors\r\n */\r\nconst updateExpressions = (exs, startRenderMidTree) => {\r\n    let oldIsInsideExpression = isInsideExpression;\r\n    isInsideExpression = true;\r\n\r\n    try {\r\n        for (let expression of exs) {\r\n            // Remove all bound props, prepare to populate updated ones\r\n            expression.boundProps.forEach(boundProp => propsToExpressions.get(boundProp).delete(expression))\r\n\r\n            let oldAlreadyAccessedProps = new Set(propsAlreadyAccessed);\r\n            if (startRenderMidTree) {\r\n                // When we're starting a render chain (expression renders child expressions and so on...) in the middle\r\n                // of the tree of expressions, we need to remember which props were accessed by ancestors of the updated\r\n                // expression, and not attribute those properties to the children when they access them.\r\n                propsAlreadyAccessed = new Set(expression.__propsAccessedByFather || []);\r\n            } else {\r\n                expression.__propsAccessedByFather = new Set(propsAlreadyAccessed);\r\n            }\r\n            let oldCurrentlyExecutingExpression = currentlyExecutingExpression;\r\n            currentlyExecutingExpression = expression;\r\n            expression.execute();\r\n            currentlyExecutingExpression = oldCurrentlyExecutingExpression;\r\n            propsAlreadyAccessed = oldAlreadyAccessedProps;\r\n        }\r\n    } finally {\r\n        isInsideExpression = oldIsInsideExpression;\r\n    }\r\n\r\n    // Update nodes with updated expression results\r\n    for (let boundNode of new Set(exs.map(ex => ex.boundNode))) {\r\n        boundNode.update()\r\n    }\r\n};\r\n\r\n/**\r\n * Receives state objects, template strings and expression callbacks inside the template, and returns a template that's bound\r\n * to the props objects.\r\n *\r\n * Steps:\r\n * 1. Create a DocumentFragment that will represent the yoffee template (it will contain elements, reference listeners, etc.)\r\n * 2. Create HTML string from the template literal: generate an ID for each expression and replace the expressions in the template with those IDs.\r\n * 3. Create a HTMLUnknownElement element that contains the previously generated HTML string. It's not connected to the DOM.\r\n * 4. Bind nodes to expressions: find the DOM nodes that contain the expressions in the HTMLUnknownElement DOM using the previously generated IDs.\r\n *    We need the HTMLUnknownElement to search because xpath root has to be an Element (not DocumentFragment)\r\n * 5. Perform first render: execute each expression while collecting the state object's properties that were accesed inside, and insert the return value\r\n *    into the DOM Node where the expression ID was. When the state object's setter is invoked, we check whether the property is bound\r\n *    to any expression, and if so, the expression is executed and DOM Node is updated, and new properties are collected on the way again.\r\n * 6. Move all children of the container element into the DocumentFragment created earlier, and return the fragment.\r\n *\r\n *  When executing an expression, we know which props were used in the expression thanks to the watchers we set earlier.\r\n *\r\n * @param propsObjects\r\n * @param strings\r\n * @param expressionCbs\r\n * @returns {DocumentFragment}\r\n */\r\nfunction createBoundDocumentFragment(propsObjects, strings, expressionCbs) {\r\n    // Create the fragment that will be returned, which contains the template\r\n    let yoffeeFragment = document.createDocumentFragment();\r\n\r\n    yoffeeFragment.__isYoffee = true;\r\n\r\n    // Create expressions and yoffee element\r\n    const expressions = expressionCbs.map(cb => new Expression(cb));\r\n    let htmlText = _joinTemplateStrings(strings, expressions.map(e => e.id));\r\n    const containerElement = _createContainerElement(htmlText);\r\n\r\n    // After this, each expression will reference a single BoundNode, which references multiple expressions.\r\n    bindNodesToExpressions(containerElement, expressions);\r\n\r\n    // This is called when the template is replaced with something else\r\n    yoffeeFragment.__removeWatchers = () => {\r\n        console.log(\"Deleting template\");\r\n\r\n        for (let expression of expressions) {\r\n            expression.boundProps.forEach(boundProp => propsToExpressions.get(boundProp).delete(expression));\r\n            expression.removeChildTemplateListeners();\r\n        }\r\n    }\r\n\r\n    // Initial render\r\n    updateExpressions(expressions);\r\n\r\n    // Add nodes into yoffee fragment\r\n    yoffeeFragment.__childNodes = [...containerElement.childNodes]\r\n    yoffeeFragment.__expressions = expressions;\r\n    yoffeeFragment.__updateExpressions = () => updateExpressions(expressions.filter(ex => !ex.isStatic && !ex.isEventHandler))\r\n    yoffeeFragment.append(...containerElement.childNodes);\r\n    return yoffeeFragment\r\n}\r\n\r\n/**\r\n * Returns a DocumentFragment that has a one-way binding to each of the objects.\r\n * @param {...Object} propsObjects Holds the state of this yoffee element\r\n * @returns {function(*=, ...[*]): DocumentFragment}\r\n */\r\nfunction html(...propsObjects) {\r\n    // Set ID for new props objects, and add watcher to prop object\r\n    propsObjects.forEach(obj => {\r\n        if (typeof obj !== \"object\") {\r\n            throw `YOFFEE: Props object must be an object, got ${typeof propsObject}`\r\n        }\r\n        else if (obj == null) {\r\n            throw `YOFFEE: Props object can't be null`\r\n        }\r\n\r\n        if (obj[NoWatchProperty] == null) {\r\n            obj[NoWatchProperty] = randomId();\r\n            watch(\r\n                obj,\r\n                onGetListener,\r\n                onSetListener\r\n            );\r\n        }\r\n    });\r\n\r\n    // This is the tagged template literal function. It receives template strings and expressions in between.\r\n    return (strings, ...expressionCbs) => {\r\n        let createTemplate = () => createBoundDocumentFragment(propsObjects, strings, expressionCbs);\r\n\r\n        // If we're inside another yoffee template, we don't create a new template because it's possible it should be cached.\r\n        // Instead, we return callback to create the template, and info to determine if should be cached (hash, expressions, propsObjects)\r\n        if (isInsideExpression) {\r\n            let deferredTemplate = {\r\n                propsObjs: propsObjects,\r\n                expressionCbs: expressionCbs,\r\n                hash: hashTemplate(strings, expressionCbs),\r\n                // cacheable: true,\r\n                // TODO: CACHING!!! UNDERSTAND THE LIST DELETION BUG SHIT\r\n                cacheable: false,\r\n            }\r\n            deferredTemplate.createYoffeeTemplate = () => {\r\n                let t = createTemplate();\r\n                deferredTemplate.yoffeeTemplate = t;\r\n                return t\r\n            }\r\n            return deferredTemplate\r\n        }\r\n\r\n        return createTemplate();\r\n    }\r\n}\r\n\r\n\r\nexport {html, createYoffeeElement, YoffeeElement}\r\n"],"names":["YoffeeElement","HTMLElement","updateProp","attr","let","attrValue","this","getAttribute","props","constructor","state","super","attributes","forEach","name","MutationObserver","mutationsList","mutation","attributeName","propUpdatedCallback","observe","attachShadow","mode","_yoffeeFragment","render","shadowRoot","appendChild","disconnectedCallback","__removeWatchers","connectedCallback","prop","createYoffeeElement","elementName","element","prototype","customElements","define","Function","renderCb","onPropUpdate","onConnect","onDisconnect","objToListeners","Map","watch","object","onGet","onSet","listeners","get","push","set","propertyName","getset","value","propsHolder","wrapWithGetSet","Object","defineProperty","properties","getOwnPropertyDescriptors","keys","setPrototypeOf","Proxy","target","Reflect","SearchLocations","find","rootElement","searchValue","searcher","type","xpath","result","document","evaluate","XPathResult","FIRST_ORDERED_NODE_TYPE","singleNodeValue","domNode","searchLocation","fillStrWithExpressions","str","expressions","exp","replace","id","_cb","toString","randomId","Array","fill","map","Math","random","substr","join","addToListInMap","key","item","list","BoundNode","expressionsLocation","_arrayDomNodes","initialValue","data","ownerElement","update","_updateTextNodeValue","_updateAttributeNodeValue","_updateAttributeNodeName","newElement","oldDomNode","expression","cached","newValue","lastResult","_lastTextNodeValue","domNodeToRemove","_removeDomNode","DocumentFragment","childNodes","length","firstChild","listLocationMarker","createElement","replaceWith","newArrayDomNodes","currentElement","insert","parentNode","insertBefore","__isYoffee","__childNodes","nextSibling","oldElement","Text","shift","createTextNode","childNode","indexOf","Node","newTextNode","remove","isEventHandler","_setEventListener","isJustExpression","includes","setPropOnPotentialYoffeeElement","removeAttributeNode","_setDomNode","removeAttribute","setAttributeNode","_lastAttributeMap","attrName","_","removePropFromPotentialYoffeeElement","entries","setAttribute","newName","getAttributeNode","listenerName","eventName","substring","handleEvent","args","addEventListener","propName","propValue","arraysEqual","a","b","i","ExpResultTypes","Expression","expressionCb","boundNode","boundProps","Set","isStatic","resultType","resultMetadata","execute","newResult","createYoffeeTemplate","handleYoffeeTemplate","isArray","handleArray","removeChildTemplateListeners","deferredTemplate","hash","propsObjs","hash2","propsObjs2","yoffeeTemplate","cacheable","__expressions","index","expressionCbs","__updateExpressions","oldHashToTemplates","newHashToTemplates","listItem","cachedTemplatesList","cachedTemplateIndex","findIndex","t","cachedTemplate","splice","shouldntDelete","templateList","values","hashToTemplates","filter","_breakUpTextNodeToSmallerNodes","textNode","textToMakeNode","wholeText","trim","textStartIndex","textEndIndex","hashTemplate","strings","reduce","accu","current","split","charCodeAt","propsToExpressions","currentlySetProp","isInsideExpression","propsAlreadyAccessed","currentlyExecutingExpression","onGetListener","obj","__notWatchedProp","has","add","onSetListener","oldPropPlaceholder","expressionsToExecute","updateExpressions","exs","startRenderMidTree","oldIsInsideExpression","boundProp","delete","oldAlreadyAccessedProps","oldCurrentlyExecutingExpression","__propsAccessedByFather","ex","createBoundDocumentFragment","propsObjects","yoffeeFragment","createDocumentFragment","cb","arr1","containerElement","html","template","startsWith","innerHTML","content","firstElementChild","navigator","userAgent","toLowerCase","adoptNode","e","domNodeToBoundNode","searchResult","localName","append","propsObject","createTemplate"],"mappings":"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"}